{"meta":{"title":"LinkX的技术站","subtitle":"","description":"程序、自动驾驶技术和人生感悟的记录","author":"LinkX","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2024-03-08T16:16:28.119Z","updated":"2024-03-08T16:16:28.119Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"Biography 我是LinkX，目前是一名自动驾驶算法工程师。 我硕士毕业于上海交通大学自动化系，研究内容为自动驾驶决策规划技术。建立本站的目的一方面是记录和分享自己的技术积累，另一方面也督促自己学习，更新技术栈。下一步的研究目标为时空联合规划和端到端自动驾驶。 Education 上海交通大学 自动化专业 硕士 2021.09~2024.03 上海交通大学 自动化专业 学士 2017.09~2021.07 Projects EM Planner精简复现：该项目为 EM Planner 算法的核心实现，在考虑障碍物情况下， 算法通过优化方式规划出最优路径，辅助车辆进行跟踪。 main 分支通过 matplot-cpp进行简易可视化； foxglove-visualizaion 分支通过 foxglove 将行驶过程可视化； RRT*-RS：在非结构化场景下，利用 Reed-Shepp 曲线连接采样点，结合 RRT*算法规划泊车路径。 Skills 程序语言：C++，Python； 路径规划算法：Dijkstra，D*，Hybrid A *，RRT * ，Open Planner，Lattice Planner，EM Planner； 决策技术：有限状态机，行为树； 控制算法：PID，Stanley，LQR，MPC； 自动驾驶开发工具：ROS，Carla，Gazebo，Foxglove，Git，Docker等；"},{"title":"Categories","date":"2024-03-05T12:44:20.000Z","updated":"2024-03-05T12:44:55.458Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2014-12-22T04:39:04.000Z","updated":"2024-03-05T12:42:57.472Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2024-03-08T07:05:16.110Z","updated":"2024-03-08T07:05:16.110Z","comments":true,"path":"life/index.html","permalink":"http://example.com/life/index.html","excerpt":"","text":"AnnGift @import url(css/page1.css); /*这里是通过@import引用CSS的样式内容*/ How long have you met each other? 37 days 38 days"},{"title":"","date":"2024-02-15T08:54:26.473Z","updated":"2024-02-15T08:54:26.473Z","comments":true,"path":"life/css/giftCard.css","permalink":"http://example.com/life/css/giftCard.css","excerpt":"","text":"@font-face { font-family: \"myFonts\"; /*字体名称*/ src: url(\"../fonts/FZZJ-FYJW.TTF\"); /*字体文件地址*/ } * { margin: 0; padding: 0; user-select: none; } .container { width: 100vw; height: 100vh; scroll-snap-type: y mandatory; overflow-y: scroll; } .frame { scroll-snap-align: start; width: 100vw; height: 100vh; } .frame:nth-child(1) { display: flex; justify-content: space-evenly; perspective: 1000px; background-blend-mode: multiply; background-color: rgba(0, 0, 0, 0.1); background-image: url(../img/back.png); background-size: cover; } .frame:nth-child(2) { display: flex; justify-content: center; align-items: center; min-height: 100vh; background-blend-mode: multiply; background-color: rgba(0, 0, 0, 0.1); background-image: url(../img/back2.png); background-size: cover; } .cardFrame { width: 300px; height: 400px; margin-top: 2%; /* position: absolute; */ } .card { width: 300px; height: 400px; background-color: #000; display: flex; justify-content: center; transform-style: preserve-3d; background-size: cover; transition: 1.5s; box-shadow: 10px 10px 10px rgba(0, 0, 0, 0.5); background-blend-mode: multiply; background-color: rgba(0, 0, 0, 0.1); } .card:hover { box-shadow: -10px 10px 10px rgba(0, 0, 0, 0.5); } .cardFrame:nth-child(1) .card { background-image: url(\"../img/Ann1.jpg\"); } .cardFrame:nth-child(2) .card { background-image: url(\"../img/Ann2.jpg\"); } .cardFrame:nth-child(3) .card { background-image: url(\"../img/Ann3.jpg\"); } .cardFrame:nth-child(1):hover .card { transform: rotateY(180deg); background-image: url(\"../img/Ann4.jpg\"); } .cardFrame:nth-child(2):hover .card { transform: rotateY(180deg); background-image: url(\"../img/Ann5.jpg\"); } .cardFrame:nth-child(3):hover .card { transform: rotateY(180deg); background-image: url(\"../img/Ann6.jpg\"); } .wordA, .wordB { position: absolute; color: rgba(255, 255, 255, 0.8); font: 900 55px \"\"; /* 设置字体间距 */ letter-spacing: 5px; line-height: 400px; } .wordA { transform: translateZ(70px); } .wordB { transform: translateZ(-70px) rotateY(180deg); } .cardB { position: relative; width: 500px; height: 600px; /* background: #fff; */ background-blend-mode: multiply; background: rgba(0, 0, 0, 0.1); background-image: url(../img/background3-1.png); background-size: cover; transform-style: preserve-3d; transform: perspective(1000px); box-shadow: 10px 10px 10px rgba(0, 0, 0, 0.25); transition: 1s; } .cardB:hover { transform: translateX(50%); } .cardB .imgBox { position: relative; width: 100%; height: 100%; z-index: 1; transform-origin: left; transform-style: preserve-3d; background: #000; transition: 1s; box-shadow: 10px 10px 10px rgba(0, 0, 0, 0.25); } .cardB:hover .imgBox { transform: rotateY(-180deg); } .cardB .imgBox img { position: absolute; left: 0; top: 0; width: 100%; height: 100%; object-fit: cover; transform-style: preserve-3d; backface-visibility: hidden; } .cardB .imgBox img:nth-child(2) { transform: rotateY(-180deg); } .cardB .details { position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 20px; /* align-items: center; */ } .cardB .details .content { /* display: flex; */ display: flex; justify-content: center; /* justify-content: center; */ /* width: 100%; height: 100%; */ font-family: \"myFonts\"; align-items: center; /* flex-direction: column; */ } .cardB .details .content h2 { text-align: center; /* font-weight: 700; */ /* left: 40%; */ font-size: 30px; } .cardB .details .content p { /* top: 40%; */ margin: 20px; /* text-align: center; */ /* font-weight: 700; */ line-height: 1em; font-size: 22px; } .cardB .details .newButton { /* display: flex; */ width: 18%; left: 13%; bottom: 30%; color: #000; font-size: 20px; border: #677d6b solid 4px; text-align: center; position: absolute; /* bottom: 10%; margin: 50px; right: 10%; */ } .cardB .details .newButton:hover { border: #dd8c30 solid 4px; } a { font-family: \"myFonts\"; color: #000; text-decoration: none; }"},{"title":"","date":"2024-02-15T08:54:26.473Z","updated":"2024-02-15T08:54:26.473Z","comments":true,"path":"life/css/page1.css","permalink":"http://example.com/life/css/page1.css","excerpt":"","text":"* { padding: 0; margin: 0; font-family: Cambria; user-select: none; } body { background-color: rgb(255, 255, 255); } .shell { width: 100%; height: 100%; background-color: rgb(255, 255, 255); overflow: hidden; /* 内部元素超出本容器后直接隐藏 */ } .page { /*transform: translateY(-110%); /*让元素移出可视画面*/ position: absolute; /* 绝对定位，坐标相对于父元素来定位, relative 是相对自己本身上一次位置进行定位 */ width: 100%; /*相对父元素百分比*/ height: 40%; background-color: #849da4; } .pageImage { position: absolute; /* 绝对定位，坐标相对于父元素来定位, relative 是相对自己本身上一次位置进行定位 */ width: 80%; /*相对父元素百分比*/ height: 75%; bottom: 15px; left: 10%; background: url(\"../img/page1.png\"); /*filter: brightness(80%);*/ background-size: cover; box-shadow: 10px 10px 10px rgba(0, 0, 0, 0.5); } .pageImage h1 { font-size: 75px; text-align: center; color: azure; margin-top: -10%; animation: imEffect; animation-duration: 2s; animation-iteration-count: 1; /* 播放几次动画*/ } @keyframes imEffect { 0% { /* % 表示执行时间，0%表示开始 */ opacity: 0; } 50% { opacity: 0.5; transform: translateY(-50px); } 100% { /* 100%表示结束 */ opacity: 1; transform: translateY(0px); } } .container { animation-name: buttonEffect; animation-duration: 3s; animation-iteration-count: 1; /* 播放几次动画*/ } .newButton { display: block; /*显示模式，有inline和block，block是块状，内部可以添加其他元素，是个容器*/ width: 20%; color: #fff; font-size: 40px; border-bottom: #fff solid 4px; text-align: center; position: absolute; top: 20%; margin: 50px; left: calc(20% + (var(--i) * 40%)); z-index: 999; /*元素堆叠顺序，越大越能显示在上面*/ /*元素过渡时间，下面应该会有这个元素的变化*/ } @keyframes buttonEffect { 0% { opacity: 0; } 50% { opacity: 0; } 75% { opacity: 0.5; } 100% { opacity: 1; } } label:hover { cursor: pointer; /*鼠标移上去会变成手的形状*/ border-bottom: solid 4px rgb(35, 35, 35); /* 设置底部边框为实线，大小和颜色*/ } a { color: #fff; text-decoration: none; } .wrongSelect { position: absolute; /* 绝对定位，坐标相对于父元素来定位, relative 是相对自己本身上一次位置进行定位 */ width: 10%; /*相对父元素百分比*/ height: 20%; top: 32%; left: 10%; background: url(\"../img/page_face1.jpg\") no-repeat; /*filter: brightness(80%);*/ background-size: contain; opacity: 0; } button { display: none; } button:active + .newButton { animation-name: shake; animation-duration: 0.4s; animation-iteration-count: 1; } @keyframes shake { 0% { transform: translate(2px, 2px); } 25% { transform: translate(-2px, -2px); } 50% { transform: translate(0px, 0px); } 75% { transform: translate(2px, -2px); } 100% { transform: translate(-2px, 2px); } }"},{"title":"","date":"2024-02-15T08:54:26.474Z","updated":"2024-02-15T08:54:26.474Z","comments":true,"path":"life/css/page2.css","permalink":"http://example.com/life/css/page2.css","excerpt":"","text":"* { padding: 0; margin: 0; font-family: Cambria; user-select: none; } body { background-color: rgb(255, 255, 255); } .shell { width: 100%; height: 100%; background-color: rgb(255, 255, 255); overflow: hidden; /* 内部元素超出本容器后直接隐藏 */ } .page { /*transform: translateY(-110%); /*让元素移出可视画面*/ position: absolute; /* 绝对定位，坐标相对于父元素来定位, relative 是相对自己本身上一次位置进行定位 */ width: 100%; /*相对父元素百分比*/ height: 40%; background-color: #96a48b; } .pageImage { position: absolute; /* 绝对定位，坐标相对于父元素来定位, relative 是相对自己本身上一次位置进行定位 */ width: 80%; /*相对父元素百分比*/ height: 75%; bottom: 15px; left: 10%; background: url(\"../img/page2.png\"); /*filter: brightness(80%);*/ background-size: cover; box-shadow: 10px 10px 10px rgba(0, 0, 0, 0.5); } .pageImage h1 { font-size: 75px; text-align: center; color: azure; margin-top: -10%; animation: imEffect; animation-duration: 2s; animation-iteration-count: 1; /* 播放几次动画*/ } @keyframes imEffect { 0% { /* % 表示执行时间，0%表示开始 */ opacity: 0; } 50% { opacity: 0.5; transform: translateY(-50px); } 100% { /* 100%表示结束 */ opacity: 1; transform: translateY(0px); } } .container { animation-name: buttonEffect; animation-duration: 3s; animation-iteration-count: 1; /* 播放几次动画*/ } .newButton { display: block; /*显示模式，有inline和block，block是块状，内部可以添加其他元素，是个容器*/ width: 20%; color: black; font-size: 40px; border-bottom: #000 solid 4px; text-align: center; position: absolute; top: 20%; margin: 50px; left: calc(20% + (var(--i) * 40%)); z-index: 999; /*元素堆叠顺序，越大越能显示在上面*/ /*元素过渡时间，下面应该会有这个元素的变化*/ } @keyframes buttonEffect { 0% { opacity: 0; } 50% { opacity: 0; } 75% { opacity: 0.5; } 100% { opacity: 1; } } label:hover { cursor: pointer; /*鼠标移上去会变成手的形状*/ border-bottom: solid 4px rgb(220, 220, 220); /* 设置底部边框为实线，大小和颜色*/ } a { color: black; text-decoration: none; } .wrongSelect { position: absolute; /* 绝对定位，坐标相对于父元素来定位, relative 是相对自己本身上一次位置进行定位 */ width: 10%; /*相对父元素百分比*/ height: 20%; top: 32%; right: 3%; background: url(\"../img/page_face2.jpg\") no-repeat; /*filter: brightness(80%);*/ background-size: contain; opacity: 0; } button { display: none; } button:active + .newButton { animation-name: shake; animation-duration: 0.4s; animation-iteration-count: 1; } @keyframes shake { 0% { transform: translate(2px, 2px); } 25% { transform: translate(-2px, -2px); } 50% { transform: translate(0px, 0px); } 75% { transform: translate(2px, -2px); } 100% { transform: translate(-2px, 2px); } }"},{"title":"","date":"2024-02-15T08:54:26.474Z","updated":"2024-02-15T08:54:26.474Z","comments":true,"path":"life/css/page3.css","permalink":"http://example.com/life/css/page3.css","excerpt":"","text":"* { padding: 0; margin: 0; font-family: Cambria; user-select: none; } body { background-color: rgb(255, 255, 255); } .shell { width: 100%; height: 100%; background-color: rgb(255, 255, 255); overflow: hidden; /* 内部元素超出本容器后直接隐藏 */ } .page { /*transform: translateY(-110%); /*让元素移出可视画面*/ position: absolute; /* 绝对定位，坐标相对于父元素来定位, relative 是相对自己本身上一次位置进行定位 */ width: 100%; /*相对父元素百分比*/ height: 40%; background-color: #7a7281; } .pageImage { position: absolute; /* 绝对定位，坐标相对于父元素来定位, relative 是相对自己本身上一次位置进行定位 */ width: 80%; /*相对父元素百分比*/ height: 75%; bottom: 15px; left: 10%; background: url(\"../img/page3.png\"); /*filter: brightness(80%);*/ background-size: cover; box-shadow: 10px 10px 10px rgba(0, 0, 0, 0.5); animation: imEffect; animation-duration: 1s; animation-iteration-count: 1; /* 播放几次动画*/ } .pageImage h1 { font-size: 75px; text-align: center; color: azure; margin-top: -10%; animation-name: buttonEffect; animation-duration: 2s; animation-iteration-count: 1; /* 播放几次动画*/ } @keyframes imEffect { 0% { /* % 表示执行时间，0%表示开始 */ opacity: 0; transform: translateX(-110%); } 100% { /* 100%表示结束 */ opacity: 1; transform: translateX(0px); } } .container { animation-name: buttonEffect; animation-duration: 2s; animation-iteration-count: 1; /* 播放几次动画*/ } .newButton { display: block; /*显示模式，有inline和block，block是块状，内部可以添加其他元素，是个容器*/ width: 20%; color: #fff; font-size: 40px; border-bottom: #fff solid 4px; text-align: center; position: absolute; top: calc(20% - (var(--i) * 5%)); margin: 50px; left: calc(20% + (var(--i) * 40%)); z-index: 999; /*元素堆叠顺序，越大越能显示在上面*/ /*元素过渡时间，下面应该会有这个元素的变化*/ } @keyframes buttonEffect { 0% { opacity: 0; } 50% { opacity: 0; } 100% { opacity: 1; } } label:hover { cursor: pointer; /*鼠标移上去会变成手的形状*/ border-bottom: solid 4px rgb(35, 35, 35); /* 设置底部边框为实线，大小和颜色*/ } a { color: #fff; text-decoration: none; } .wrongSelect { position: absolute; /* 绝对定位，坐标相对于父元素来定位, relative 是相对自己本身上一次位置进行定位 */ width: 10%; /*相对父元素百分比*/ height: 20%; top: 32%; left: 10%; background: url(\"../img/page_face3.jpg\") no-repeat; /*filter: brightness(80%);*/ background-size: contain; opacity: 0; } button { display: none; } button:active + .newButton { animation-name: shake; animation-duration: 0.4s; animation-iteration-count: 1; } @keyframes shake { 0% { transform: translate(2px, 2px); } 25% { transform: translate(-2px, -2px); } 50% { transform: translate(0px, 0px); } 75% { transform: translate(2px, -2px); } 100% { transform: translate(-2px, 2px); } }"},{"title":"","date":"2024-02-15T08:54:26.475Z","updated":"2024-02-15T08:54:26.475Z","comments":true,"path":"life/css/page4.css","permalink":"http://example.com/life/css/page4.css","excerpt":"","text":"* { padding: 0; margin: 0; font-family: Cambria; user-select: none; } body { background-color: rgb(255, 255, 255); } .shell { width: 100%; height: 100%; background-color: rgb(255, 255, 255); overflow: hidden; /* 内部元素超出本容器后直接隐藏 */ } .page { /*transform: translateY(-110%); /*让元素移出可视画面*/ position: absolute; /* 绝对定位，坐标相对于父元素来定位, relative 是相对自己本身上一次位置进行定位 */ width: 100%; /*相对父元素百分比*/ height: 40%; background-color: #7b8b6f; } .pageImage { position: absolute; /* 绝对定位，坐标相对于父元素来定位, relative 是相对自己本身上一次位置进行定位 */ width: 80%; /*相对父元素百分比*/ height: 75%; bottom: 15px; left: 10%; background: url(\"../img/page4.png\"); /*filter: brightness(80%);*/ background-size: cover; box-shadow: 10px 10px 10px rgba(0, 0, 0, 0.5); animation: imEffect; animation-duration: 1s; animation-iteration-count: 1; /* 播放几次动画*/ } .pageImage h1 { font-size: 75px; text-align: center; color: azure; margin-top: -10%; animation-name: buttonEffect; animation-duration: 2s; animation-iteration-count: 1; /* 播放几次动画*/ } @keyframes imEffect { 0% { /* % 表示执行时间，0%表示开始 */ opacity: 0; transform: translateX(+100%); } 100% { /* 100%表示结束 */ opacity: 1; transform: translateX(0px); } } .container { animation-name: buttonEffect; animation-duration: 2s; animation-iteration-count: 1; /* 播放几次动画*/ } .newButton { display: block; width: 20%; color: #fff; font-size: 40px; border-bottom: #fff solid 4px; text-align: center; position: absolute; top: 0; margin: 50px; left: calc(20% + (var(--i) * 15%)); z-index: 999; } @keyframes buttonEffect { 0% { opacity: 0; } 50% { opacity: 0; } 100% { opacity: 1; } } label:hover { cursor: pointer; /*鼠标移上去会变成手的形状*/ border-bottom: solid 4px rgb(35, 35, 35); /* 设置底部边框为实线，大小和颜色*/ } a { color: #fff; text-decoration: none; } .wrongSelect { position: absolute; /* 绝对定位，坐标相对于父元素来定位, relative 是相对自己本身上一次位置进行定位 */ width: 10%; /*相对父元素百分比*/ height: 20%; top: 32%; left: 10%; background: url(\"../img/wrongSelect.jpg\") no-repeat; /*filter: brightness(80%);*/ background-size: contain; opacity: 0; } button { display: none; } button:active + .newButton { animation-name: shake; animation-duration: 0.4s; animation-iteration-count: 1; } @keyframes shake { 0% { transform: translate(2px, 2px); } 25% { transform: translate(-2px, -2px); } 50% { transform: translate(0px, 0px); } 75% { transform: translate(2px, -2px); } 100% { transform: translate(-2px, 2px); } }"},{"title":"","date":"2024-03-08T07:03:40.221Z","updated":"2024-03-08T07:03:40.221Z","comments":true,"path":"life/assets/fire.html","permalink":"http://example.com/life/assets/fire.html","excerpt":"","text":"body { margin: 0; padding: 0; overflow: hidden; } .city { width: 100%; position: fixed; bottom: 0px; z-index: 100; } .city img { width: 100%; } FireworksForAnn 浏览器不支持canvas 安安 生日快乐 var canvas = document.getElementById(\"cas\"); var ocas = document.createElement(\"canvas\"); var octx = ocas.getContext(\"2d\"); var ctx = canvas.getContext(\"2d\"); ocas.width = canvas.width = window.innerWidth; ocas.height = canvas.height = 700; var bigbooms = []; window.onload = function () { initAnimate(); }; function initAnimate() { drawBg(); lastTime = new Date(); animate(); } var lastTime; function animate() { ctx.save(); ctx.fillStyle = \"rgba(0,5,24,0.1)\"; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.restore(); var newTime = new Date(); if (newTime - lastTime > 500 + (window.innerHeight - 767) / 2) { var random = Math.random() * 100 > 2 ? true : false; var x = getRandom(canvas.width / 5, (canvas.width * 4) / 5); var y = getRandom(50, 200); if (random) { var bigboom = new Boom( getRandom(canvas.width / 3, (canvas.width * 2) / 3), 2, \"#FFF\", { x: x, y: y } ); bigbooms.push(bigboom); } else { var bigboom = new Boom( getRandom(canvas.width / 3, (canvas.width * 2) / 3), 2, \"#FFF\", { x: canvas.width / 2, y: 200 }, document.querySelectorAll(\".shape\")[ parseInt( getRandom(0, document.querySelectorAll(\".shape\").length) ) ] ); bigbooms.push(bigboom); } lastTime = newTime; console.log(bigbooms); } stars.foreach(function () { this.paint(); }); drawMoon(); bigbooms.foreach(function (index) { var that = this; if (!this.dead) { this._move(); this._drawLight(); } else { this.booms.foreach(function (index) { if (!this.dead) { this.moveTo(index); } else if (index === that.booms.length - 1) { bigbooms[bigbooms.indexOf(that)] = null; } }); } }); raf(animate); } function drawMoon() { var moon = document.getElementById(\"moon\"); var centerX = canvas.width - 200, centerY = 100, width = 80; if (moon.complete) { ctx.drawImage(moon, centerX, centerY, width, width); } else { moon.onload = function () { ctx.drawImage(moon, centerX, centerY, width, width); }; } var index = 0; for (var i = 0; i < 10; i++) { ctx.save(); ctx.beginPath(); ctx.arc( centerX + width / 2, centerY + width / 2, width / 2 + index, 0, 2 * Math.PI ); ctx.fillStyle = \"rgba(240,219,120,0.005)\"; index += 2; ctx.fill(); ctx.restore(); } } Array.prototype.foreach = function (callback) { for (var i = 0; i < this.length; i++) { if (this[i] !== null) callback.apply(this[i], [i]); } }; var raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) { window.setTimeout(callback, 1000 / 60); }; canvas.onclick = function () { var x = event.clientX; var y = event.clientY; var bigboom = new Boom( getRandom(canvas.width / 3, (canvas.width * 2) / 3), 2, \"#FFF\", { x: x, y: y } ); bigbooms.push(bigboom); }; // canvas.addEventLisener(\"touchstart\" , function(event){ // var touch = event.targetTouches[0]; // var x = event.pageX; // var y = event.pageY; // var bigboom = new Boom(getRandom(canvas.width/3,canvas.width*2/3) ,2,\"#FFF\" , {x:x , y:y}); // bigbooms.push(bigboom) // }) var Boom = function (x, r, c, boomArea, shape) { this.booms = []; this.x = x; this.y = canvas.height + r; this.r = r; this.c = c; this.shape = shape || false; this.boomArea = boomArea; this.theta = 0; this.dead = false; this.ba = parseInt(getRandom(80, 200)); }; Boom.prototype = { _paint: function () { ctx.save(); ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, 2 * Math.PI); ctx.fillStyle = this.c; ctx.fill(); ctx.restore(); }, _move: function () { var dx = this.boomArea.x - this.x, dy = this.boomArea.y - this.y; this.x = this.x + dx * 0.01; this.y = this.y + dy * 0.01; if (Math.abs(dx)"},{"title":"","date":"2024-03-08T07:03:46.185Z","updated":"2024-03-08T07:03:46.185Z","comments":true,"path":"life/assets/giftCard.html","permalink":"http://example.com/life/assets/giftCard.html","excerpt":"","text":"AnnGiftCard @import url(../css/giftCard.css); Ann Happy Birthday 关于太阳花的记忆 风暴曾送来她的花瓣， 鸟儿也传达过她的叹息 浓雾渐起，太阳隐匿 那是北国的太阳花， 曾尽受阳光的宠浴 如今在雨里，他们相互偎依 相隔太近，千里之外仍有花的问语 相隔太远，百步之内却又无法触及 关于太阳花的记忆 热烈，温暖和惋惜 太阳终将升起 海鸟终有归期 或是一个清夜 皓月当空 烟花旖旎 最后，看场烟花吧"},{"title":"","date":"2024-03-08T07:03:51.728Z","updated":"2024-03-08T07:03:51.728Z","comments":true,"path":"life/assets/page2.html","permalink":"http://example.com/life/assets/page2.html","excerpt":"","text":"AnnGift @import url(../css/page2.css); How many movies have you seen together? 3 movies 4 movies"},{"title":"","date":"2024-03-08T07:03:58.451Z","updated":"2024-03-08T07:03:58.451Z","comments":true,"path":"life/assets/page3.html","permalink":"http://example.com/life/assets/page3.html","excerpt":"","text":"AnnGift @import url(../css/page3.css); What do you think of him? Outstanding Very Outstanding"},{"title":"","date":"2024-03-08T07:04:04.990Z","updated":"2024-03-08T07:04:04.990Z","comments":true,"path":"life/assets/page4.html","permalink":"http://example.com/life/assets/page4.html","excerpt":"","text":"AnnGift @import url(../css/page4.css); Do you like him? Yes"},{"title":"","date":"2024-02-15T08:54:26.661Z","updated":"2024-02-15T08:54:26.661Z","comments":true,"path":"life/js/common.js","permalink":"http://example.com/life/js/common.js","excerpt":"","text":"$(document).ready(function () { $(\"#button1\").click(function () { var my_button = $(\"#face\"); my_button.animate( { left: \"-=2px\", top: \"-=2px\", opacity: \"1\" }, \"slow\" ); my_button.animate({ opacity: \"0\" }); my_button.animate({ left: \"+=2px\", top: \"+=2px\", opacity: \"0\" }); }); });"},{"title":"","date":"2024-02-15T08:54:26.660Z","updated":"2024-02-15T08:54:26.660Z","comments":true,"path":"life/jquery/jquery.js","permalink":"http://example.com/life/jquery/jquery.js","excerpt":"","text":"/*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !(function (e, t) { \"use strict\"; \"object\" == typeof module && \"object\" == typeof module.exports ? (module.exports = e.document ? t(e, !0) : function (e) { if (!e.document) throw new Error(\"jQuery requires a window with a document\"); return t(e); }) : t(e); })(\"undefined\" != typeof window ? window : this, function (C, e) { \"use strict\"; var t = [], r = Object.getPrototypeOf, s = t.slice, g = t.flat ? function (e) { return t.flat.call(e); } : function (e) { return t.concat.apply([], e); }, u = t.push, i = t.indexOf, n = {}, o = n.toString, v = n.hasOwnProperty, a = v.toString, l = a.call(Object), y = {}, m = function (e) { return ( \"function\" == typeof e && \"number\" != typeof e.nodeType && \"function\" != typeof e.item ); }, x = function (e) { return null != e && e === e.window; }, E = C.document, c = { type: !0, src: !0, nonce: !0, noModule: !0 }; function b(e, t, n) { var r, i, o = (n = n || E).createElement(\"script\"); if (((o.text = e), t)) for (r in c) (i = t[r] || (t.getAttribute && t.getAttribute(r))) && o.setAttribute(r, i); n.head.appendChild(o).parentNode.removeChild(o); } function w(e) { return null == e ? e + \"\" : \"object\" == typeof e || \"function\" == typeof e ? n[o.call(e)] || \"object\" : typeof e; } var f = \"3.6.0\", S = function (e, t) { return new S.fn.init(e, t); }; function p(e) { var t = !!e && \"length\" in e && e.length, n = w(e); return ( !m(e) && !x(e) && (\"array\" === n || 0 === t || (\"number\" == typeof t && 0 < t && t - 1 in e)) ); } (S.fn = S.prototype = { jquery: f, constructor: S, length: 0, toArray: function () { return s.call(this); }, get: function (e) { return null == e ? s.call(this) : e < 0 ? this[e + this.length] : this[e]; }, pushStack: function (e) { var t = S.merge(this.constructor(), e); return (t.prevObject = this), t; }, each: function (e) { return S.each(this, e); }, map: function (n) { return this.pushStack( S.map(this, function (e, t) { return n.call(e, t, e); }) ); }, slice: function () { return this.pushStack(s.apply(this, arguments)); }, first: function () { return this.eq(0); }, last: function () { return this.eq(-1); }, even: function () { return this.pushStack( S.grep(this, function (e, t) { return (t + 1) % 2; }) ); }, odd: function () { return this.pushStack( S.grep(this, function (e, t) { return t % 2; }) ); }, eq: function (e) { var t = this.length, n = +e + (e < 0 ? t : 0); return this.pushStack(0"}],"posts":[{"title":"环境配置索引","slug":"环境配置日志/环境配置索引","date":"2024-03-12T02:44:00.000Z","updated":"2024-03-12T05:10:36.729Z","comments":true,"path":"2024/03/c6992dae00e1.html","permalink":"http://example.com/2024/03/c6992dae00e1.html","excerpt":"本页面存放一系列环境配置内容文档的索引；","text":"本页面存放一系列环境配置内容文档的索引； 1. Windows 环境 Windows系统迁移笔记 Windows下Eigen、osqp和osqp-eigen库的安装使用 Windows下Ipopt优化库安装","categories":[{"name":"环境配置日志","slug":"环境配置日志","permalink":"http://example.com/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"#环境配置索引","slug":"环境配置索引","permalink":"http://example.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%B4%A2%E5%BC%95/"}]},{"title":"凸优化基础","slug":"最优化方法/凸优化基础","date":"2024-03-12T02:43:00.000Z","updated":"2024-03-12T05:43:09.189Z","comments":true,"path":"2024/03/b5bc8dd591f5.html","permalink":"http://example.com/2024/03/b5bc8dd591f5.html","excerpt":"凸优化问题的两个基本条件： 目标函数 cost function 是凸函数，即存在极小值； 求解空间是凸空间，是完整的空间，而不是破碎的。","text":"凸优化问题的两个基本条件： 目标函数 cost function 是凸函数，即存在极小值； 求解空间是凸空间，是完整的空间，而不是破碎的。","categories":[{"name":"最优化方法","slug":"最优化方法","permalink":"http://example.com/categories/%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"}],"tags":[]},{"title":"最优化方法索引","slug":"最优化方法/最优化方法索引","date":"2024-03-12T02:39:00.000Z","updated":"2024-03-12T02:45:51.262Z","comments":true,"path":"2024/03/017bb123671c.html","permalink":"http://example.com/2024/03/017bb123671c.html","excerpt":"本页面主要存放最优化方法学习笔记的索引，方便进行页面检索；","text":"本页面主要存放最优化方法学习笔记的索引，方便进行页面检索； 1. 基础理论 凸优化基础 KKT条件 2. 优化方法 梯度下降法 牛顿法 共轭梯度法 高斯牛顿法","categories":[{"name":"最优化方法","slug":"最优化方法","permalink":"http://example.com/categories/%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"#最优化方法索引","slug":"最优化方法索引","permalink":"http://example.com/tags/%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E7%B4%A2%E5%BC%95/"}]},{"title":"Python笔记索引","slug":"Python/Python笔记索引","date":"2024-03-12T02:30:00.000Z","updated":"2024-03-12T02:45:51.262Z","comments":true,"path":"2024/03/944e778b7f6e.html","permalink":"http://example.com/2024/03/944e778b7f6e.html","excerpt":"本页面主要存放平时 Python 使用过程中的笔记索引，方便进行文章检索；","text":"本页面主要存放平时 Python 使用过程中的笔记索引，方便进行文章检索； 1. Python语言特性 多线程与多进程 2. 实用代码 D-star算法实现","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[{"name":"#Python笔记索引","slug":"Python笔记索引","permalink":"http://example.com/tags/Python%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95/"}]},{"title":"D-star算法实现","slug":"Python/实用代码/D-star算法实现","date":"2024-03-12T02:30:00.000Z","updated":"2024-03-12T02:35:56.989Z","comments":true,"path":"2024/03/ff932a6a77c6.html","permalink":"http://example.com/2024/03/ff932a6a77c6.html","excerpt":"Python 实现路径规划中的D*算法；","text":"Python 实现路径规划中的D*算法； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 2018/12/13 0013 22:30# @Author : 心一# @Site : # @File : D_star.py# @Software: PyCharmimport mathfrom sys import maxsize # 导入最大数，2^63-1class State(object): def __init__(self, x, y): self.x = x self.y = y self.parent = None self.state = &quot;.&quot; self.t = &quot;new&quot; self.h = 0 self.k = 0 # k即为f def cost(self, state): if self.state == &quot;#&quot; or state.state == &quot;#&quot;: return maxsize # 存在障碍物时，距离无穷大 return math.sqrt(math.pow((self.x - state.x), 2) + math.pow((self.y - state.y), 2)) def set_state(self, state): if state not in [&quot;S&quot;, &quot;.&quot;, &quot;#&quot;, &quot;E&quot;, &quot;*&quot;,&quot;+&quot;]: return self.state = stateclass Map(object): &#x27;&#x27;&#x27; 创建地图 &#x27;&#x27;&#x27; def __init__(self, row, col): self.row = row self.col = col self.map = self.init_map() def init_map(self): # 初始化map map_list = [] for i in range(self.row): tmp = [] for j in range(self.col): tmp.append(State(i, j)) map_list.append(tmp) return map_list def print_map(self): for i in range(self.row): tmp = &quot;&quot; for j in range(self.col): tmp += self.map[i][j].state + &quot; &quot; print(tmp) def get_neighbers(self, state): # 获取8邻域 state_list = [] for i in [-1, 0, 1]: for j in [-1, 0, 1]: if i == 0 and j == 0: continue if state.x + i &lt; 0 or state.x + i &gt;= self.row: continue if state.y + j &lt; 0 or state.y + j &gt;= self.col: continue state_list.append(self.map[state.x + i][state.y + j]) return state_list def set_obstacle(self, point_list): # 设置障碍物的位置 for x, y in point_list: if x &lt; 0 or x &gt;= self.row or y &lt; 0 or y &gt;= self.col: continue self.map[x][y].set_state(&quot;#&quot;)class Dstar(object): def __init__(self, maps): self.map = maps self.open_list = set() # 创建空集合 def process_state(self): &#x27;&#x27;&#x27; D*算法的主要过程 :return: &#x27;&#x27;&#x27; x = self.min_state() # 获取open list列表中最小k的节点 if x is None: return -1 k_old = self.get_kmin() #获取open list列表中最小k节点的k值 self.remove(x) # 从openlist中移除 # 判断openlist中 if k_old &lt; x.h: for y in self.map.get_neighbers(x): if y.h &lt;= k_old and x.h &gt; y.h + x.cost(y): x.parent = y x.h = y.h + x.cost(y) # 领域的 h 值发生了改变 if k_old == x.h: for y in self.map.get_neighbers(x): if y.t == &quot;new&quot; or y.parent == x and y.h != x.h + x.cost(y) \\ or y.parent != x and y.h &gt; x.h + x.cost(y): y.parent = x self.insert(y, x.h + x.cost(y)) else: for y in self.map.get_neighbers(x): if y.t == &quot;new&quot; or y.parent == x and y.h != x.h + x.cost(y): y.parent = x self.insert(y, x.h + x.cost(y)) else: if y.parent != x and y.h &gt; x.h + x.cost(y): self.insert(x, x.h) else: if y.parent != x and x.h &gt; y.h + x.cost(y) \\ and y.t == &quot;close&quot; and y.h &gt; k_old: self.insert(y, y.h) return self.get_kmin() def min_state(self): if not self.open_list: return None min_state = min(self.open_list, key=lambda x: x.k) # 获取openlist中k值最小对应的节点 return min_state def get_kmin(self): # 获取openlist表中k(f)值最小的k if not self.open_list: return -1 k_min = min([x.k for x in self.open_list]) return k_min def insert(self, state, h_new): if state.t == &quot;new&quot;: state.k = h_new elif state.t == &quot;open&quot;: state.k = min(state.k, h_new) elif state.t == &quot;close&quot;: state.k = min(state.h, h_new) state.h = h_new state.t = &quot;open&quot; self.open_list.add(state) def remove(self, state): if state.t == &quot;open&quot;: state.t = &quot;close&quot; self.open_list.remove(state) def modify_cost(self, x): if x.t == &quot;close&quot;: # 是以一个openlist，通过parent递推整条路径上的cost self.insert(x, x.parent.h + x.cost(x.parent)) def run(self, start, end): self.insert(end,0) while True: self.process_state() if start.t == &quot;close&quot;: break start.set_state(&quot;S&quot;) s = start while s != end: s = s.parent s.set_state(&quot;+&quot;) s.set_state(&quot;E&quot;) print(&#x27;障碍物未发生变化时，搜索的路径如下：&#x27;) print(&quot;opset 大小：&quot;, len(self.open_list)) self.map.print_map() tmp = start # 起始点不变 self.map.set_obstacle([(1,2)]) # 障碍物发生变化 &#x27;&#x27;&#x27; 从起始点开始，往目标点行进，当遇到障碍物时，重新修改代价，再寻找路径 &#x27;&#x27;&#x27; while tmp != end: tmp.set_state(&quot;*&quot;) # self.map.print_map() # print(&quot;&quot;) if tmp.parent.state == &quot;#&quot;: self.modify(tmp) continue tmp = tmp.parent tmp.set_state(&quot;E&quot;) print(&#x27;障碍物发生变化时，搜索的路径如下(*为更新的路径)：&#x27;) self.map.print_map() def modify(self, state): &#x27;&#x27;&#x27; 当障碍物发生变化时，从目标点往起始点回推，更新由于障碍物发生变化而引起的路径代价的变化 :param state: :return: &#x27;&#x27;&#x27; self.modify_cost(state) while True: k_min = self.process_state() if k_min &gt;= state.h: breakif __name__ == &#x27;__main__&#x27;: m = Map(4,4) # m.set_obstacle([(4, 3), (4, 4), (4, 5), (4, 6), (5, 3), (6, 3), (7, 3)]) start = m.map[3][0] end = m.map[0][3] dstar = Dstar(m) dstar.run(start, end) # m.print_map()","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"实用代码","slug":"Python/实用代码","permalink":"http://example.com/categories/Python/%E5%AE%9E%E7%94%A8%E4%BB%A3%E7%A0%81/"}],"tags":[]},{"title":"多线程与多进程","slug":"Python/Python语言特性/多线程与多进程","date":"2024-03-12T02:27:00.000Z","updated":"2024-03-12T02:35:56.989Z","comments":true,"path":"2024/03/cfb368e8b4c6.html","permalink":"http://example.com/2024/03/cfb368e8b4c6.html","excerpt":"对 Python 中并发和并行概念； GIL锁介绍解释；","text":"对 Python 中并发和并行概念； GIL锁介绍解释； 1. 基本概念 1.1 并发与并行 并发(concurrency)： CPU单核运行，只不过将任务分块，使用GIL(全局解释器锁，Cpython解释器特性)锁定当前执行任务块，释放后执行其他线程任务块，造成多任务同时处理的宏观效果。对应于 python 中的多线程 (thread) 并行(parallel)： 多核同时处理任务，真正的同步处理。对应于python 中多进程（multiprocessing）。 1.2 GIL锁为什么产生 核心原因： CPU处理和IO读取可以同步，因此可以将等待IO读取的时间用来处理其他任务，从而提高效率。 python 开发时多是单核处理器，为解决多任务之间数据同步和完整问题，所以使用GIL锁。 1.3 计算任务分类 CPU密集型计算(CPU-bound)： IO读取较少，主要使用CPU核心计算功能的任务，例如矩阵运算，适合使用多进程处理。 IO密集型计算(IO-bound)： IO处理很多（硬盘、磁盘和网络数据交互）等，数值处理和计算较少，适合使用多线程处理。 2. 线程安全 由于GIL存在，多线程在切换时可能会产生数据读写冲突，一般通过对线程加锁解决。 3. 线程池 在多线程中，创建和销毁线程很耗时，如果能够做好线程的管理和复用，那可以进一步提高效率。线程池的使用就是为了实现这一目的，并且简化了线程的创建。 1from concurrent import futures # futures 是python 中实现线程池的重要模块","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"Python语言特性","slug":"Python/Python语言特性","permalink":"http://example.com/categories/Python/Python%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"}],"tags":[]},{"title":"Windows下Eigen、osqp和osqp-eigen库的安装使用","slug":"环境配置日志/Windows下Eigen、osqp和osqp-eigen库的安装使用","date":"2024-03-11T01:19:00.000Z","updated":"2024-03-11T01:28:44.740Z","comments":true,"path":"2024/03/fc1fc6c9cd69.html","permalink":"http://example.com/2024/03/fc1fc6c9cd69.html","excerpt":"项目 EM Planner 中需要使用到 Eigen，osqp以及osqp-eigen库，这里介绍如何在 windows 下编译安装这些基本库的方法； 这里只进行依赖库安装说明，需要项目还是在 linux 下开发，环境配置会简单很多。","text":"项目 EM Planner 中需要使用到 Eigen，osqp以及osqp-eigen库，这里介绍如何在 windows 下编译安装这些基本库的方法； 这里只进行依赖库安装说明，需要项目还是在 linux 下开发，环境配置会简单很多。 1. Eigen 库编译安装与使用 1.1 编译安装 Eigen Eigen3 官网 Eigen 可以不用编译成库，因为其所有文件都是 .hpp 头文件形式，没有库文件，可以直接放在自己工程文件中使用，只要在 CMakeLists.txt 的 include_directories() 中放入Eigen目录即可。但最好还是将 Eigen 编译成库文件使用，编译安装方法见这里，可以自定义安装目录，最后使用 find_package(Eigen3 REQUIRED) 就可以找到对应的 .make 文件，比较神奇，因为按理来说需要指定安装的目录来查找对应的文件。 1.2 使用 Eigen 这里是直接将 Eigen 编译安装了，CMakeLists.txt 文档可写成如下形式： 1234567cmake_minimum_required(VERSION 3.20) project(smoothFrenet)find_package(Eigen3 REQUIRED)add_executable(main main) target_link_libraries(main Eigen3::Eigen) 2. osqp 库编译安装与使用 2.1 编译安装 osqp osqp官网 osqp 库的安装与 Eigen 类似，安装方法同样参考这里。因为直接安装到系统目录需要管理员权限，并且每次使用都要赋予权限，比较麻烦，所以还是将其安装到自定义的文件夹内。 2.2 使用 osqp 主要介绍 CMakeLists.txt 文档的编写： 12345678910111213cmake_minimum_required(VERSION 3.20) project(test) set(CMAKE_CXX_STANDARD 14)# 指定 osqp 安装目录，不然找不到对应的cmake文件find_package(osqp REQUIRED PATHS D:/cppThirdParty/libInstall/osqpLib NO_DEFAULT_PATH) add_executable(test main.cpp) #使用静态库 osqp::osqpstatic,对应的是 .a 文件，而不要使用 osqp::osqptarget_link_libraries(test osqp::osqpstatic) 注意点： 1. find_package() 时指定路径； 2. 使用静态库 osqp::osqptatic。 3. osqp-eigen 库的编译安装与使用 osqp-eigen 官网 osqp 主要是用 c 语言完成，关于矩阵的表示与运算比较底层，所以使用起来很不方便。因此使用在 osqp 基础上开发的 osqp-eigen 库会方便很多。其依赖于 osqp 和 Eigen，按照上面的常规步骤进行编译可以成功，但在使用时会找不到库文件，问题可以出在这两个地方： 1. 因为 osqp 库是安装在自定义目录，所以 osqp-eigen 没有找到要使用的库文件。 这里我已经将 osqp-eigen 的相关 .cmake 文件进行了更改，并且最后编译也通过了，所以问题出在这里的可能性比较小，但由于无法排查，所以在这里也记录一下。 2. 编译该库没有生成 .a 文件，只生成了 libOsqpEigen.dll.a 和 libOsqpEigen.dll 两种库文件。而按照之前在 cmake 中使用的情况，貌似即使是在 windows 内，也是需要使用 .a 的库文件，所以怀疑问题出在这里。 由于始终无法正常使用，所以准备自己将这个库编译一下。 3.1 编译 osqp-eigen 库 主要使用 cmake 中 add_library() 完成静态库编译，下面是详细的 CMakeLists.txt： 12345678910111213141516171819202122232425cmake_minimum_required(VERSION 3.20)project(osqp_eigen)include_directories(./include)# 将 ./src 下面的全部.cpp 文件放到变量 DIR_LIB_SRCS 中aux_source_directory(./src DIR_LIB_SRCS)find_package(Eigen3 REQUIRED)find_package(osqp REQUIRED PATHS D:/cppThirdParty/libInstall/osqpLib NO_DEFAULT_PATH)# 生成静态库add_library(osqp_eigen STATIC $&#123;DIR_LIB_SRCS&#125;)# 链接需要使用的外部库target_link_libraries(osqp_eigen Eigen3::Eigen osqp::osqpstatic)# 安装生成的静态库文件osqp_eigen 至&lt;CMAKE_INSTALL_PREFIX&gt;/lib中，ARCHIVE 代表静态库install(TARGETS osqp_eigen ARCHIVE DESTINATION lib)# 将整个 ./include下面的文件夹安装至 &lt;CMAKE_INSTALL_PREFIX&gt;/include中，这里是头文件install(DIRECTORY ./include/ DESTINATION include)message(STATUS $&#123;DIR_LIB_SRCS&#125;&quot;--构建库完成&quot;) 然后按照常规编译安装步骤就可以将头文件和库文件安装到设定位置了。 3.2 使用 osqp-eigen 库 这里因为没有写相关的 .cmake 配置文件，所以就无法使用相关的 find_package() 来自动寻找库文件了，所以手动配置一下，后续再考虑自动查找的设置。 123456789101112131415161718cmake_minimum_required(VERSION 3.20) project(osqp_eigen) set(CMAKE_CXX_STANDARD 14) # 这里在 &lt;CMAKE_PREFIX_PATH&gt; 中添加了osqp安装库的位置，所以下面的 find_package()就不用再重新设置路径了set(CMAKE_PREFIX_PATH $&#123;CMAKE_PREFIX_PATH&#125; “D:/cppThirdParty/libInstall/osqpLib”) set(OSQPEIGEN_INCLUDE_DIR D:/cppThirdParty/libInstall/osqpEigenLib/include) set(OSQPEIGEN_LIB_DIR D:/cppThirdParty/libInstall/osqpEigenLib/lib) find_package(Eigen3 REQUIRED) find_package(osqp REQUIRED) include_directories($&#123;OSQPEIGEN_INCLUDE_DIR&#125;) link_directories($&#123;OSQPEIGEN_LIB_DIR&#125;) add_executable(main main.cpp) target_link_libraries(main libosqp_eigen.a Eigen3::Eigen osqp::osqpstatic) 4. 使用例子 各种优化问题 官方example","categories":[{"name":"环境配置日志","slug":"环境配置日志","permalink":"http://example.com/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97/"}],"tags":[]},{"title":"Windows下Ipopt优化库安装","slug":"环境配置日志/Windows下Ipopt优化库安装","date":"2024-03-11T01:14:00.000Z","updated":"2024-03-11T01:30:05.361Z","comments":true,"path":"2024/03/9aad1447aa31.html","permalink":"http://example.com/2024/03/9aad1447aa31.html","excerpt":"Ipopt 是进行非线性优化问题求解的三方库，这里介绍在 Windows 环境下的安装方法； 这里只进行依赖库安装说明，需要项目还是在 linux 下开发，环境配置会简单很多。","text":"Ipopt 是进行非线性优化问题求解的三方库，这里介绍在 Windows 环境下的安装方法； 这里只进行依赖库安装说明，需要项目还是在 linux 下开发，环境配置会简单很多。 1. 类UNIX环境 MSYS2 / MINGW 安装 官网下载安装 注意！！！ 以下编译 HSL 时出现的问题都是由于运行的是 msys2.exe 这个终端，包括找不到 gcc 编译器等原因。实际应该使用 mingw64.exe 终端！ 安装其他软件包： 1pacman --disable-download-timeout -S binutils diffutils git grep make patch pkg-config Note: 这里在安装时可能有些包提示签名未授权，类似这样的提示 error: gcc-libs: signature from \"David Macek david.macek.0@gmail.com\" is unknown trust 这里需要更新一下 Key 就行： 1pacman-key --keyserver keyserver.ubuntu.com --refresh-keys 使用 GNU 编译器 1pacman --disable-download-timeout -S mingw-w64-x86_64-gcc mingw-w64-x86_64-gcc-fortran 使用 MINGW 时，可以安装对应的 Lapack 1pacman -S mingw-w64-x86_64-lapack 2. 安装 Ipopt 的依赖库 ipopt官网 OpenBLAS 直接从 github 的网站上下载二进制文件包即可。 对于linux，直接使用apt-get安装。 1sudo apt-get install libopenblas-dev LAPACK 已经在前面安装 MinGW 时安装了。 HSL 这里使用的是个人免费版本，然后需要在 Msys 中使用源码编译。 需要注意的点包括： Windows 下的路径表示与 Unix 下的表示不同，因此需要进行转换，官方提供了转换工具 cygpath ，使用示例： 12345$ cygpath - u &quot;D:\\ipoptProject\\ThirdParty-HSL&quot;-u/d/ipoptProject/ThirdParty-HSL$ cd /d/ipoptProject/ThirdParty-HSL 若编译时提示找不到 gcc 编译器，但是在 mingw64/bin 中存在编译器，则检查路径是否包括编译器： 12$ $PATH #若不包括路径，则添加上去$ PATH=$PATH:/mingw64/bin 3. 编译测试文件 这是 example/examples/hs071_cpp 中 makefile 的编译顺序，在终端中按照如此方式进行可正常编译。这里使用的是包管理器 pkg-config 去处理需要添加的库路径与库文件。 1231. g++ -O2 -DNDEBUG `PKG_CONFIG_PATH=/mingw64/lib/pkgconfig:/mingw64/lib/pkgconfig:/mingw64/share/pkgconfig pkg-config --cflags ipopt` -c -o hs071_main.o hs071_main.cpp2. g++ -O2 -DNDEBUG `PKG_CONFIG_PATH=/mingw64/lib/pkgconfig:/mingw64/lib/pkgconfig:/mingw64/share/pkgconfig pkg-config --cflags ipopt` -c -o hs071_nlp.o hs071_nlp.cpp3. g++ -O2 -DNDEBUG -o hs071_cpp.exe hs071_main.o hs071_nlp.o `PKG_CONFIG_PATH=/mingw64/lib/pkgconfig:/mingw64/lib/pkgconfig:/mingw64/share/pkgconfig pkg-config --libs ipopt` 其中 pkg-config --cflags --libs ipopt 命令实际是找到 ipopt 库中头文件，库文件所在目录，以及要链接的必要库名称： 123$ PKG_CONFIG_PATH=/mingw64/lib/pkgconfig:/mingw64/lib/pkgconfig:/mingw64/share/pkgconfig pkg-config --cflags --libs ipopt-I/mingw64/include/coin-or -I/mingw64/include/coin-or/hsl -I/mingw64/include/coin-or/mumps -L/mingw64/lib -lipopt -lcoinhsl -lcoinmumps -llapack -lblas 但是我想直接使用 -o 命令生成可执行文件，不需要产生中间文件，于是做了以下尝试： 1g++ hs071_nlp.cpp hs071_main.cpp -o main.exe -I. &#x27;PKG_CONFIG_PATH=/mingw64/lib/pkgconfig:/mingw64/lib/pkgconfig:/mingw64/share/pkgconfig pkg-config --cflags --libs ipopt&#x27; 却会报错如下： 123456789In file included from hs071_nlp.cpp:7:hs071_nlp.hpp:10:10: fatal error: IpTNLP.hpp: No such file or directory 10 | #include &quot;IpTNLP.hpp&quot; | ^~~~~~~~~~~~compilation terminated.hs071_main.cpp:8:10: fatal error: IpIpoptApplication.hpp: No such file or directory 8 | #include &quot;IpIpoptApplication.hpp&quot; | ^~~~~~~~~~~~~~~~~~~~~~~~compilation terminated. 然后就折腾了一整天，按理来说应该是没有问题的，直到我写这个文档时，才发现了这个问题，原来 PKG_CONFIG_PATH=...ipopt 这段配置语句是用 ` ` 括起来的，而不是单引号 ' ' 。所以正确的语句应该是 1g++ hs071_nlp.cpp hs071_main.cpp -o main.exe -I. `PKG_CONFIG_PATH=/mingw64/lib/pkgconfig:/mingw64/lib/pkgconfig:/mingw64/share/pkgconfig pkg-config --cflags --libs ipopt`","categories":[{"name":"环境配置日志","slug":"环境配置日志","permalink":"http://example.com/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97/"}],"tags":[]},{"title":"Windows系统迁移笔记","slug":"环境配置日志/Windows系统迁移笔记","date":"2024-03-11T01:11:00.000Z","updated":"2024-03-12T05:10:36.729Z","comments":true,"path":"2024/03/5a0267b9e9ef.html","permalink":"http://example.com/2024/03/5a0267b9e9ef.html","excerpt":"由于笔记本只有一个硬盘位，所以想扩大硬盘容量只能换硬盘。但又不想重装系统及各种软件，所以需要进行系统迁移。希望达到的效果就是原硬盘上的系统和数据全都拷贝到新硬盘上，并且还能够适时的调整各个分区大小。","text":"由于笔记本只有一个硬盘位，所以想扩大硬盘容量只能换硬盘。但又不想重装系统及各种软件，所以需要进行系统迁移。希望达到的效果就是原硬盘上的系统和数据全都拷贝到新硬盘上，并且还能够适时的调整各个分区大小。 1. 方法 使用傲梅轻松备份软件。 选择 克隆 下的 磁盘克隆； |600 选定 源磁盘 和 目标磁盘，选定目标磁盘后会提示清除目标磁盘上数据，因此得提前做好备份。 选择左下角编辑分区，可以手动调整克隆到目标磁盘后的各个分区大小。 调整分区结束后勾选 SSD对齐 ，然后进行克隆。 将新的硬盘安装到笔记本上就行，因为无论是引导方式还是硬盘格式都相同，所以并不需要做其他更改，也不需要使用 WinPE 系统进行修复。 2. 参考 教程","categories":[{"name":"环境配置日志","slug":"环境配置日志","permalink":"http://example.com/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97/"}],"tags":[]},{"title":"VsCode配置使用","slug":"Ubuntu/linux笔记/VsCode配置使用","date":"2024-03-11T00:47:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/d681f865a872.html","permalink":"http://example.com/2024/03/d681f865a872.html","excerpt":"Vscode 的配置记录，方便在新平台时快速的配置开发环境。","text":"Vscode 的配置记录，方便在新平台时快速的配置开发环境。 1. 使用cmake编译 快速自动创建CMakeLists.txt文件 ctrl+shift+p 打开控制面板，搜索 cmake ，选择 quick start。 输入项目名，用以配置CMakeList.txt中要求的项目名。 选择 create an executable ，创建可执行文件而不是库文件。 生成了CMakeLists.txt，然后修改其中内容。 使用底部工具栏的 build 和 run 按钮就可以进行编译运行和调试，这里并不需要 launch.json 和 task.json 文件，因为是 cmake 编译。会再工作空间自动产生一个 build 文件夹。","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/categories/Ubuntu/"},{"name":"linux笔记","slug":"Ubuntu/linux笔记","permalink":"http://example.com/categories/Ubuntu/linux%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"linux笔记索引","slug":"Ubuntu/linux笔记索引","date":"2024-03-10T11:35:00.000Z","updated":"2024-03-12T02:49:19.372Z","comments":true,"path":"2024/03/1267f843f03d.html","permalink":"http://example.com/2024/03/1267f843f03d.html","excerpt":"本页面主要存放在ubuntu(linux)使用过程的一系列教程和注意事项的文章索引，方便查找对应文章。","text":"本页面主要存放在ubuntu(linux)使用过程的一系列教程和注意事项的文章索引，方便查找对应文章。 1. 软件教程 创建Python虚拟环境 Ubuntu安装卸载软件的各类方法 AppImage文件创建快捷方式 Git Vim Cmake g++编译规则 update-alternatives管理不同版本软件 VsCode配置使用 2. linux常用命令 查看文件及文件夹大小 删除root权限的文件夹 添加与删除环境变量 压缩与解压缩文件夹 内核查看与更改 3. 注意事项 Legacy电脑安装ubuntu注意事项","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/categories/Ubuntu/"}],"tags":[{"name":"#linux笔记检索","slug":"linux笔记检索","permalink":"http://example.com/tags/linux%E7%AC%94%E8%AE%B0%E6%A3%80%E7%B4%A2/"}]},{"title":"Vim","slug":"Ubuntu/linux笔记/Vim","date":"2024-03-10T11:30:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/1f72a9d2ee08.html","permalink":"http://example.com/2024/03/1f72a9d2ee08.html","excerpt":"vim 的一些基本操作方法。","text":"vim 的一些基本操作方法。 1. Normal 模式 gg 回到顶行。 G 回到文档末尾。 u 撤回上一步操作。 查找和替换： 1234/word #查找文档中所有 word 单词，按 n 向后搜索下一个结果，N 向前搜索。:s/word/test/ #替换当前行中第一个word为test:s/word/test/g #替换当前行中所有word为test:%s/word/test/g #替换全文中所有word为test ctrl+f(forward) 向下翻一页 ctrl+b(backward) 向上翻一页 ctrl+d(down) 向下翻半页 ctrl+u(up) 向上翻半页 2. Insert 模式 按 i 进入该模式，然后可进行编辑操作 3. Visual 模式 按 v 进入该模式，可多选字符串进行复制、粘贴和删除操作。 - d 删除选择文本 - c 删除选择文本并进入 insert 模式 - y 复制 - x 剪切 - p 粘贴","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/categories/Ubuntu/"},{"name":"linux笔记","slug":"Ubuntu/linux笔记","permalink":"http://example.com/categories/Ubuntu/linux%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"update-alternatives管理不同版本软件","slug":"Ubuntu/linux笔记/update-alternatives管理不同版本软件","date":"2024-03-10T11:27:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/1b7d9387f42b.html","permalink":"http://example.com/2024/03/1b7d9387f42b.html","excerpt":"ubuntu下使用 update-alternatives 管理不同版本软件，例如 cmake ，g++ 等，避免因完全卸载原软件导致系统配置出错的最佳方式。","text":"ubuntu下使用 update-alternatives 管理不同版本软件，例如 cmake ，g++ 等，避免因完全卸载原软件导致系统配置出错的最佳方式。 1. 相关命令 以Cmake为例 安装不同版本cmake，安装到自己目录 sudo make install DESTDIR=/home/myDir 使用update-alternatives创建软连接 12#update-alternatives --install [系统搜索路径] [软件名] [软件实际安装路径] [优先级]sudo update-alternatives --install /usr/bin/cmake cmake /usr/local/bin/cmake 1 查看某一软件的update-alternatives配置情况，用以查看当前正在使用的版本 1sudo update-alternatives --display cmake 更改软件多个版本 1sudo update-alternatives --config cmake 移除软件某一个版本的配置 12##update-alternatives --remove [软件名] [软件实际安装路径]sudo update-alternatives --remove cmake /usr/local/bin/cmake 移除软件所有配置 1sudo update-alternatives --remove-all cmake 2. 参考 使用update-alternatives命令进行版本的切换 linux软件版本管理命令update-alternatives使用详解","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/categories/Ubuntu/"},{"name":"linux笔记","slug":"Ubuntu/linux笔记","permalink":"http://example.com/categories/Ubuntu/linux%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Git","slug":"Ubuntu/linux笔记/Git","date":"2024-03-10T11:10:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/ac15c72d52cb.html","permalink":"http://example.com/2024/03/ac15c72d52cb.html","excerpt":"git 的一系列基本操作； 解析 git 的设计原理，包括 git merge 和 git rebase 等；","text":"git 的一系列基本操作； 解析 git 的设计原理，包括 git merge 和 git rebase 等； 1. 分支 1.1 查看分支 123git branch # 查看本地分支git branch -r #查看远程分支git branch -a #查看所有分支，红色为远程 1.2 切换分支 12git checkout [branch] #切换到已有分支git checkout -b [newbranch] #创建并切换到新分支 1.3 推送分支到远端 1git push -u origin [newbranch] #首次推送分支到远端，之后直接使用 git push origin [newbranch] 即可 1.4 删除分支 12git push origin --delete [branch] #删除远端分支git branch -D [branch] #删除本地分支 1.5 清空远程分支方法 123git rm -r --cached . #清除本地缓存git commit -m&quot;delete&quot;git push origin main ### 2. 克隆 #### 2.1 克隆特定分支文件 1git clone -b [branch] [仓库链接] #### 2.2 一次性批量克隆仓库到本地 使用 vcs 命令实现批量下载，例如某 build_depends.repos 文件内容如下 1234567891011121314151617repositories: common: type: git url: https://gitlab.com/autowarefoundation/autoware.ai/common.git version: master lanelet2: type: git url: https://github.com/fzi-forschungszentrum-informatik/Lanelet2.git version: master messages: type: git url: https://gitlab.com/autowarefoundation/autoware.ai/messages.git version: master mrt_cmake_modules: type: git url: https://github.com/KIT-MRT/mrt_cmake_modules.git version: master 在同级文件夹下使用命令： 1vcs import ..&lt;&lt;build_depends.repos 将文件中的仓库批量下载至上一级文件夹 .. 当中。 3. 忽略文件或文件夹 在git工作空间下创建 .gitignore 文件（注意不是在 .git 文件夹下创建），若要忽略 build 和 .vscode 文件夹，则可以在 .gitignore 中写道： 123# .gitignore文件内容build.vscode 若要忽略的文件已经添加到缓存区，删除 1234git ls-files #缓存查看git rm -r --cached [要忽略文件夹]git add .git commit -m &quot;提交描述&quot; 4. git merge 相关操作 --ff --no-ff 5. git merge 和 git rebase 区别 两种方式都是合并分支，但是有差别。 #### 5.1 git merge 1. 简介： git merge 合并以后，两个分支的commit 信息还各自按照时间线保留，只不过是一种交叉方式的合并，在 git 树中存在交叉。 2. 使用场景： 由各自的 feature 分支向 develop 分支合并。 12git checkout maingit merge --no-ff develop image.png|400 5.2 git rebase 简介： 顾名思义，就是重新选择基础，也就是重新选择 rebase 的分支为基础，然后达到一个线性合并的方式。会找到两个分支的上一个共有 commit，然后插入 rebase 分支的新 commit 。 使用场景： 在本地清理自己的各种分支，主打一个简洁，并不需要多关注以前的 commit 时间和信息。 12git checkout maingit rebase develop image.png|400","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/categories/Ubuntu/"},{"name":"linux笔记","slug":"Ubuntu/linux笔记","permalink":"http://example.com/categories/Ubuntu/linux%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"g++编译规则","slug":"Ubuntu/linux笔记/g++编译规则","date":"2024-03-10T09:10:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/565a36c551fa.html","permalink":"http://example.com/2024/03/565a36c551fa.html","excerpt":"直接使用 g++ 编译 cpp源码的基本方法；","text":"直接使用 g++ 编译 cpp源码的基本方法； 1. 基本规则 1.1 参数 -c : 生成目标文件，只编译不链接，即链接库文件之前的文件，后缀一般为 .o 。 1g++ -c main.cpp // 会生成 main.o 的目标文件 -o：生成可执行文件。 1g++ -o main main.cpp -L. -lstaticlib // 利用源文件 main.cpp 与./ 中的库文件一起生成可执行文件 main -L: 要链接的库文件所在目录。 12-L. //库在当前目录-L/usr/lib -l: 需要链接的库的名称。注意不是库文件名称，例如 libtest.a 是静态库文件名称，其 对应的库名称为 test。因为在 linux 中编译时库文件的命名为 lib[库名称].a 或者 lib[库名称].so ，前者为静态库，后者为动态库。 -I: 指定头文件目录。可以使用相对路径，即： 12-I./include-I/usr/include -shared：指定生成动态库。 -fPIC ： 表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时事通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码共享的目的。 2. 使用示例 在[[Ipopt优化库安装#编译测试文件]] 中有大量实例显示如何用 g++ 编译。 创建静态库文件。 先生成目标文件： 1g++ -c file1.cpp 利用目标文件创建静态库。其中静态库名字为 xxxx，库文件名字为 libxxxx.a 。在生成可执行文件时需要用 -lxxxx 。 1ar cqs libxxxx.a xx1.o xx2.o xx3.o 创建动态库文件： 直接利用源文件生成动态库文件。库名称和库文件名称区别如上。 1g++ -fPIC -shared -o libxxxx.so xx1.cpp xx2.cpp xx3.cpp 链接库文件，创建可执行文件。 1g++ -o main main.cpp -LfilePath -lxxxx","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/categories/Ubuntu/"},{"name":"linux笔记","slug":"Ubuntu/linux笔记","permalink":"http://example.com/categories/Ubuntu/linux%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Cmake","slug":"Ubuntu/linux笔记/Cmake","date":"2024-03-10T09:05:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/aa6722f125a9.html","permalink":"http://example.com/2024/03/aa6722f125a9.html","excerpt":"windows 中使用cmake编译程序方法； CMakeLists.txt 撰写方法，控制程序的安装、查找； linux中使用 update-alternatives 更新 cmake；","text":"windows 中使用cmake编译程序方法； CMakeLists.txt 撰写方法，控制程序的安装、查找； linux中使用 update-alternatives 更新 cmake； 1. 在 windows 下使用 cmake 编译安装库文件 在源代码文件下新建 build 文件夹并进入，利用 cmake 构建 makefile 文件： 1cmake -G &quot;MinGW Makefiles&quot; -DCMAKE_INSTALL_PREFIX:PATH=D:/first/second .. 需要用 -G 指定编译链，其中包含了 g++ 和 gcc 等工具； -DCMAKE_INSTALL_PREFIX:PATH=D:/first/second 指定了安装文件夹 .. 表示 CmakeLists.txt 文件在上一层目录下 在 build 文件夹中，使用 cmake 编译文件 1cmake --build . 紧接着安装库文件 1cmake --build . --target install 当想卸载库文件时执行 1cmake --build . --target uninstall 2. 编写 CMakelists.txt 为自己的库创建 .make 配置文件，使得 find_package() 可以找到 3. ubuntu下升级 cmake 的方式 正确升级方法 4. 参考 cmake系统变量 cmake动态库与静态库安装","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/categories/Ubuntu/"},{"name":"linux笔记","slug":"Ubuntu/linux笔记","permalink":"http://example.com/categories/Ubuntu/linux%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"AppImage文件创建快捷方式","slug":"Ubuntu/linux笔记/AppImage文件创建快捷方式","date":"2024-03-10T08:54:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/773fc7eb7c9a.html","permalink":"http://example.com/2024/03/773fc7eb7c9a.html","excerpt":"ubuntu 中配置 AppImage 文件，并在菜单中显示应用图标的方法； 解决启动后侧边栏两个图标问题；","text":"ubuntu 中配置 AppImage 文件，并在菜单中显示应用图标的方法； 解决启动后侧边栏两个图标问题； 1. 配置方法 这里以 marktext 软件为例： 首先需要将 AppImage 文件的权限改为以可执行文件运行！（右键属性） 1. 解压 AppImage 文件，解压后文件存放于 squashfs-root ，将其重命名为 marktext。 1./marktext-x86_64.AppImage --appimage-extract 在以下目录创建启动文件 obsidian.desktop /home/linkx/.local/share/applications 内容为： 12345678[Desktop Entry]Name=ObsidianComment=Aplicación de mensajeríaExec=/home/linkx/Software/obsidian/Obsidian.AppImage #应用程序位置Icon=/home/linkx/Software/obsidian/squashfs-root/obsidian.png #图标位置Terminal=falseType=ApplicationCategories=Internet; 2. APP 启动后侧边栏有两个图标 先打开应用，然后终端运行命令 xprop WM_CLASS 。此时鼠标变成加号，使用鼠标点击应用窗口，得到终端输出： 12$ xprop WM_CLASSWM_CLASS(STRING) = &quot;obsidian&quot;, &quot;obsidian&quot; 然后修改桌面启动文件，例如 Obsidian.desktop，添加一行内容，例如： 123456789[Desktop Entry]Name=ObsidianComment=Aplicación de mensajeríaExec=//home/linkx/Software/obsidian/Obsidian.AppImageIcon=/home/linkx/Software/obsidian/squashfs-root/obsidian.pngTerminal=falseType=ApplicationCategories=Internet;StartupWMClass=obsidian #添加内容 重启即可。 3. 参考 参考","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/categories/Ubuntu/"},{"name":"linux笔记","slug":"Ubuntu/linux笔记","permalink":"http://example.com/categories/Ubuntu/linux%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"终端常用快捷键操作","slug":"Ubuntu/linux笔记/终端常用快捷键操作","date":"2024-03-10T08:46:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/44a6a49c3ff4.html","permalink":"http://example.com/2024/03/44a6a49c3ff4.html","excerpt":"基础操作 1234567891011ctrl + a #移动到行首ctrl + e(end) #移动到行尾ctrl + k #删除至末尾元素ctrl + u #删除至开头元素ctrl + w(word) #剪切左边第一个单词ctrl + y(yank) #粘贴剪切的单词alt + f(forward) #往后移动一个单词alt + b(backward) #往前移动一个单词","text":"基础操作 1234567891011ctrl + a #移动到行首ctrl + e(end) #移动到行尾ctrl + k #删除至末尾元素ctrl + u #删除至开头元素ctrl + w(word) #剪切左边第一个单词ctrl + y(yank) #粘贴剪切的单词alt + f(forward) #往后移动一个单词alt + b(backward) #往前移动一个单词 反向搜索 12ctrl + r（reverse） #输入文字搜索历史记录-&gt; #right_arrow 退出反向搜索模式","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/categories/Ubuntu/"},{"name":"linux笔记","slug":"Ubuntu/linux笔记","permalink":"http://example.com/categories/Ubuntu/linux%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"压缩与解压缩文件夹","slug":"Ubuntu/linux笔记/压缩与解压缩文件夹","date":"2024-03-10T08:44:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/6cba42028c3d.html","permalink":"http://example.com/2024/03/6cba42028c3d.html","excerpt":".tar，.tar.gz ，.bz2 和 .zip 文件的压缩和解压方法。","text":".tar，.tar.gz ，.bz2 和 .zip 文件的压缩和解压方法。 1. .tar 文件的压缩与解压 1. 压缩 以 test 文件夹为例，压缩为 test.tar 压缩包 12# 格式：tar -vcf 打包后的文件名(xxx.tar) 需要打包的文件夹(xxx)tar -vcf test.tar test 2. 解压 12#格式：tar -vxf 打包后的文件名(xxx.tar)tar -vxf test.tar 2. .tar.gz 文件的压缩与解压 1. 压缩 12#格式：tar -vczf 打包压缩后的文件名(xxx.tar.gz) 需要打包的文件夹(xxx)tar -vczf test.tar.gz test 2. 解压缩 12#格式：tar -vxzf 打包压缩后的文件名(xxx.tar.gz)tar -vxzf test.tar.gz 3. .bz2 文件的压缩 1. 压缩 1bzip2 -z test 2. 解压 1bzip2 -d test.bz2 4. .zip 文件的压缩与解压 1. 压缩 12345#格式：zip 打包压缩的文件名(xxx.zip) 需要打包的文件夹(xxx)zip test.zip test#递归处理，即将子文件夹也一并压缩zip -r test.zip test 2. 解压 12345#格式： unzip xxxx.zipunzip test.zip#使用 -d 命令解压到指定目录unzip test.zip -d /target_folder","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/categories/Ubuntu/"},{"name":"linux笔记","slug":"Ubuntu/linux笔记","permalink":"http://example.com/categories/Ubuntu/linux%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"添加与删除环境变量","slug":"Ubuntu/linux笔记/添加与删除环境变量","date":"2024-03-10T08:43:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/596479257e81.html","permalink":"http://example.com/2024/03/596479257e81.html","excerpt":"","text":"ubuntu 中添加环境变量与删除环境变量 1export // 查看所有环境变量 1234//添加环境变量export PATH=$PATH:/usr/local/go/binexport GOPATH=/home/gopath 12//删除环境变量export -n GOPATH","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/categories/Ubuntu/"},{"name":"linux笔记","slug":"Ubuntu/linux笔记","permalink":"http://example.com/categories/Ubuntu/linux%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Ubuntu安装卸载软件的各类方法","slug":"Ubuntu/linux笔记/Ubuntu安装卸载软件的各类方法","date":"2024-03-10T08:31:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/d3c98baa0d11.html","permalink":"http://example.com/2024/03/d3c98baa0d11.html","excerpt":"总结ubuntu中各种安装和卸载软件的方法，包括 snap，dpkg 等。","text":"总结ubuntu中各种安装和卸载软件的方法，包括 snap，dpkg 等。 1. snap方式 对于 typora： - 安装： 1sudo snap install typora - 卸载： 1sudo snap remove typora 2. .deb 文件 安装： 1sudo dpkg -i [file.deb]","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/categories/Ubuntu/"},{"name":"linux笔记","slug":"Ubuntu/linux笔记","permalink":"http://example.com/categories/Ubuntu/linux%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Legacy电脑安装ubuntu注意事项","slug":"Ubuntu/linux笔记/Legacy电脑安装ubuntu注意事项","date":"2024-03-10T08:30:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/19dbbdee38e4.html","permalink":"http://example.com/2024/03/19dbbdee38e4.html","excerpt":"","text":"电脑主板的引导方式分为 legacy 引导和 UEFI 引导。较新主板的引导都为UEFI，而lagacy引导需要注意以下事项： - 引导方式是 legacy，需要用EASYBCD 创建引导。 - 在安装ubuntu时分区的文件格式均为 ext3。","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/categories/Ubuntu/"},{"name":"linux笔记","slug":"Ubuntu/linux笔记","permalink":"http://example.com/categories/Ubuntu/linux%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"删除root权限的文件夹","slug":"Ubuntu/linux笔记/删除root权限的文件夹","date":"2024-03-10T08:26:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/961d865ad079.html","permalink":"http://example.com/2024/03/961d865ad079.html","excerpt":"","text":"sudo rm -rf [dirname]","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/categories/Ubuntu/"},{"name":"linux笔记","slug":"Ubuntu/linux笔记","permalink":"http://example.com/categories/Ubuntu/linux%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"内核查看与更改","slug":"Ubuntu/linux笔记/内核查看与更改","date":"2024-03-10T08:24:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/e7d261d37b2f.html","permalink":"http://example.com/2024/03/e7d261d37b2f.html","excerpt":"ubuntu查看并更换系统内核的方法； 禁止在 upgrade 命令下更新内核的方法；","text":"ubuntu查看并更换系统内核的方法； 禁止在 upgrade 命令下更新内核的方法； 1. 内核查看 当前内核版本 1uname -a 已安装的所有内核 1dpkg --get-selections |grep linux-image |500 2. 删除内核 12sudo apt-get remove --purge linux-image-4.15.0-194-genericsudo apt autoremove #删除内核的一些依赖文件 3. 安装新内核 1sudo apt-get install linux-headers-4.15.0-47-generic linux-image-4.15.0-47-generic 安装成功以后重启，在 advanced options 中可以看到新安装的内核。 4. 禁止自动更新内核 禁止在使用 upgrade 命令时自动更新内核，需要修改两个配置文件： 12sudo gedit /etc/apt/apt.conf.d/10periodicsudo gedit /etc/apt/apt.conf.d/20auto-upgrades 将其内容修改为： 1234APT::Periodic::Update-Package-Lists &quot;0&quot;;APT::Periodic::Download-Upgradeable-Packages &quot;0&quot;;APT::Periodic::AutocleanInterval &quot;0&quot;;APT::Periodic::Unattended-Upgrade &quot;0&quot;; 若需要打开自动更新配置文件，则将内容更改为： 1234APT::Periodic::Update-Package-Lists &quot;2&quot;;APT::Periodic::Download-Upgradeable-Packages &quot;1&quot;;APT::Periodic::AutocleanInterval &quot;0&quot;;APT::Periodic::Unattended-Upgrade &quot;1&quot;; 5. 参考 禁止自动更新内核 安装新内核","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/categories/Ubuntu/"},{"name":"linux笔记","slug":"Ubuntu/linux笔记","permalink":"http://example.com/categories/Ubuntu/linux%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"创建Python虚拟环境","slug":"Ubuntu/linux笔记/创建Python虚拟环境","date":"2024-03-10T08:20:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/1b808778e65d.html","permalink":"http://example.com/2024/03/1b808778e65d.html","excerpt":"使用 virtualenv 创建Python虚拟环境的基本配置方法； 不同虚拟环境设置不同Python 版本的方法；","text":"使用 virtualenv 创建Python虚拟环境的基本配置方法； 不同虚拟环境设置不同Python 版本的方法； 1. 基础设置 下载功能包 12sudo pip3 install virtualenv sudo pip3 install virtualenvwrapper 创建存放虚拟路径的文件夹 1mkdir $HOME/.virtualenvs 添加环境变量，注意因为是用 pip3 下载的功能包，则需要指定使用 python3 运行。打开 .bashrc 文件，并添加以下内容： 12345export WORKON_HOME=$HOME/.virtualenvsexport VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3export VIRTUALENVWRAPPER_VIRTUALENV=/usr/local/bin/virtualenvsource /usr/local/bin/virtualenvwrapper.sh 使得环境配置生效 1source .bashrc 创建虚拟环境 12mkvirtualenv [虚拟环境] # 默认是在 python2 中mkvirtualenv -p python3 [虚拟环境名称] #python3 版本 查看所有创建的虚拟环境 1workon 进入某一虚拟环境 1workon [虚拟环境名] 退出虚拟环境 1deactivate 删除虚拟环境 12# 必须先退出虚拟环境再进行删除 rmvirtualenv [虚拟环境名称] 2. 创建不同 python 版本的虚拟环境 上述配置中使用的解释器为系统python，若想在虚拟环境中使用不同的python解释器，需要下载安装自己所需python版本，然后在创建虚拟环境时指定 python。 - 自定义下载安装 python 123456789wget -c https://www.python.org/ftp/python/3.9.0/Python-3.9.0.tgztax -xzvf Python-3.9.0.tgz# wget -P ~/Downloads https://www.python.org/ftp/python/3.10.0/Python-3.10.0.tar.xz./configure make# 自定义python安装路径，不要和系统混淆make install DESTDIR=~/python_version/python3.9.0_build - 创建 virtualenv 虚拟环境时指定python解释器 1mkvirtualenv -p ~/python_version/python3.9.0_build/python3.9 [虚拟环境名]","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/categories/Ubuntu/"},{"name":"linux笔记","slug":"Ubuntu/linux笔记","permalink":"http://example.com/categories/Ubuntu/linux%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"查看文件及文件夹大小","slug":"Ubuntu/linux笔记/查看文件及文件夹大小","date":"2024-03-10T08:20:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/1875b8f30cd2.html","permalink":"http://example.com/2024/03/1875b8f30cd2.html","excerpt":"linux 中查看文件以及文件夹大小的各项命令，包括 ls，ll 和 du。","text":"linux 中查看文件以及文件夹大小的各项命令，包括 ls，ll 和 du。 1. ls 命令 ls ： 查看当前目录下各文件 ls -l： 查看各文件详细信息，第一列代表文件属性，- 为普通文件，d 为文件夹，l 为软连接。 注意 autoscan* 后的 * 表示有可执行权限。 ls -lh : 以 KB 或 MB 的形式显示文件大小，注意对于文件夹，这里的数值并不是这个文件夹下所有文件大小，只是这个文件夹符所占大小。查看文件夹大小使用 1du -sh 文件夹 2. ll 命令 ll 命令实际就是 ls -l 的简写，所以有以下等效： - ll -s -&gt; ls -ls - ll -h -&gt; ls -lh 3. du 命令 查看文件夹下各个文件夹及其本身大小 1du -h --max-depth=1 查看本文件夹总大小 1du -sh 查看本文件夹下某个子文件夹大小 1du -sh 文件夹名","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/categories/Ubuntu/"},{"name":"linux笔记","slug":"Ubuntu/linux笔记","permalink":"http://example.com/categories/Ubuntu/linux%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"KKT条件","slug":"最优化方法/KKT条件","date":"2024-03-09T16:06:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/db850e69690f.html","permalink":"http://example.com/2024/03/db850e69690f.html","excerpt":"等式约束的优化问题：使用拉格朗日乘数法构建拉格朗日函数，利用求取极值的必要性，转换为无约束优化问题，可以使用梯度下降法、牛顿法，共轭梯度法等方法进行迭代求解。 带有不等式约束的优化问题：构建广义拉格朗日函数，然后使用KKT条件进行求解。","text":"等式约束的优化问题：使用拉格朗日乘数法构建拉格朗日函数，利用求取极值的必要性，转换为无约束优化问题，可以使用梯度下降法、牛顿法，共轭梯度法等方法进行迭代求解。 带有不等式约束的优化问题：构建广义拉格朗日函数，然后使用KKT条件进行求解。 1. 基本原理 对于带约束的优化问题（不一定是凸问题）： \\[ \\begin{array}{ll} \\min &amp; f_0(\\boldsymbol{x}), \\boldsymbol{x} \\in \\mathbb{R}^n \\\\ &amp; f_i(\\boldsymbol{x}) \\leq 0 \\text {, 其中 } \\mathrm{i}=1,2,3 \\ldots \\mathrm{m} \\\\ \\text { s.t. } &amp; h_i(\\boldsymbol{x})=0 \\text {, 其中 } \\mathrm{i}=1,2,3 \\ldots q \\end{array} \\] 1.1 首先构建拉格朗日函数，将原问题进行等价转换： image.png 问题：为什么拉格朗日乘子\\(\\lambda \\geq 0\\)？ 答：为了使得原函数 \\(f_{0}(x)\\) 等价为 极大的拉格朗日函数。也就是上面的当 x 在可行域和不在可行域时需要满足的条件，从而将原问题等价为极小极大拉格朗日问题。 1.2 将原问题转换为对偶问题，就是最大最小过程进行交换： image.png 这里，对偶问题进行进一步转化： \\[ \\begin{array}{ll} 对偶问题: &amp;\\max _{\\lambda, v} L(x,\\lambda, v) \\\\ \\text { s.t. } &amp; \\nabla_{\\boldsymbol{x}} L(\\boldsymbol{x}, \\boldsymbol{\\lambda}, \\boldsymbol{v})=\\mathbf{0} \\\\ &amp; \\boldsymbol{\\lambda} \\geq \\mathbf{0} \\end{array} \\] 注意对偶函数 \\(g(\\lambda,v)\\)的变量为 \\(\\lambda,v\\) ，然后分析对偶函数： - \\(g(\\lambda,v)\\) 是关于变量的线性函数，因此既是凸函数也是凹函数； - 对偶问题可行域为 \\(\\lambda \\geq 0\\) ，是半空间，因此为凸空间。 所以无论原问题是不是凸问题，对偶问题一定是凸问题。 1.3 对偶问题于原问题之间解的关系 对偶问题的解是原问题解的下界，这是弱对偶关系，即 \\(P* \\geq D*\\)。 对偶问题的解是原问题的解，这是强对偶关系，即 \\(P* = D*\\) image.png 1.4 原始问题要是一个强对偶问题 需要满足： - 原始问题为凸问题； - 满足 Slack 条件； 1.5 最终，如何求解一个带约束的凸优化问题 使用 KKT 条件求解，KKT 条件是原始问题为强对偶问题的必要条件，也就是说原始问题如果是强对偶，那么一定满足KKT条件，但满足KKT条件，不一定是强对偶。 互补松弛是构建拉格朗日函数时需要满足的，就是松弛条件和紧致条件的特性的统一表示。 image.png 2. 补充 松弛条件和紧致条件 image.png 3. 参考 KKT条件简要说明 拉格朗日对偶性","categories":[{"name":"最优化方法","slug":"最优化方法","permalink":"http://example.com/categories/%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"}],"tags":[]},{"title":"梯度下降法","slug":"最优化方法/梯度下降法","date":"2024-03-09T16:06:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/57eb35381a43.html","permalink":"http://example.com/2024/03/57eb35381a43.html","excerpt":"求解无约束优化问题的经典方法； 步长（学习率）通过人为设定；","text":"求解无约束优化问题的经典方法； 步长（学习率）通过人为设定； 1. 基本原理 对于无约束优化问题： \\[ min \\quad f(x) \\] 将目标函数在 \\(x_{k}\\) 处进行一阶泰勒展开 \\[ \\begin{aligned} f(x_{k+1}) &amp;= f(x_{k}) + g(x_{k})(x_{k+1} - x_{k}) \\\\ g(x_{k}) &amp;= f&#39;(x_{k}) \\end{aligned} \\] 梯度下降法的目标是希望 \\(f(x)\\) 在当前所在位置向下降量最大的方向扩展，即： \\[ \\begin{aligned} f(x_{k+1}) - f(x_{k}) &amp;= g(x_{k}) \\cdot \\alpha \\vec{v} \\\\ &amp; = \\alpha \\times ||g(x_{k})|| \\times ||\\vec{v}|| \\times cos(\\theta) \\end{aligned} \\] 所以要使得 \\(f(x_{k+1}) - f(x_{k})\\) 的绝对值最大，并且为负，需要 \\(cos(\\theta) = -1\\)，即 \\(\\vec{v} = -g(x_{k})\\)，所以有： \\[ x_{k+1} = x_{k} - \\alpha \\times g(x_{k}) \\] 2. 局限性 在靠近极值点时更新步长会变得很小，由此造成迭代次数过大。 3. 参考 梯度下降算法的数学推导_","categories":[{"name":"最优化方法","slug":"最优化方法","permalink":"http://example.com/categories/%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"}],"tags":[]},{"title":"牛顿法","slug":"最优化方法/牛顿法","date":"2024-03-09T16:05:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/c814794462ec.html","permalink":"http://example.com/2024/03/c814794462ec.html","excerpt":"求解无约束优化问题的经典方法； 需要目标函数的二阶导数（海塞矩阵）获取步长；","text":"求解无约束优化问题的经典方法； 需要目标函数的二阶导数（海塞矩阵）获取步长； 1. 基本原理 同样对于无约束优化问题： \\[ min \\quad f(x) \\] 我们求其导数的零点，就可以得到函数极值，并且若 \\(f&#39;&#39;(x_{k})&gt;0\\) ，那么 \\(x_{k}\\) 就是函数极小值点。 将目标函数在 \\(x_{k}\\) 处进行二阶泰勒展开： \\[ f(x_{k+1}) = f(x_{k}) + f&#39;(x_{k})(x_{k+1} - x_{k}) + \\frac{1}{2}f&#39;&#39;(x_{k})(x_{k+1}-x_{k})^{2} \\] 求一阶导数零点，即 \\[ \\begin{aligned} f&#39;(x_{k}) + f&#39;&#39;(x_{k})(x_{k+1}-x_{k}) &amp;= f(x_{k+1})&#39; \\\\ &amp; = 0 \\\\ \\end{aligned} \\] 得到递增方向： \\[ \\begin{aligned} x_{k+1} &amp;= x_{k} - (f&#39;&#39;(x_{k}))^{-1}f&#39;(x_{k}) \\\\ &amp;= x_{k} - (f&#39;&#39;(x_{k}))^{-1}g(x_{k}) \\end{aligned} \\] 2. 对比梯度下降法 梯度下降法： \\[ x_{k+1} = x_{k} - \\alpha \\times g(x_{k}) \\] 牛顿法： \\[ x_{k+1} = x_{k} - (f&#39;&#39;(x_{k}))^{-1}g(x_{k}) \\] 所以牛顿法其实是通过海塞矩阵求取了一个步长，其迭代速度相比梯度下降法会快很多，但是海塞矩阵的求解与求逆却相对要难很多。 3. 局限性 要求给定的方程需要二阶可导 非凸函数的海塞矩阵不一定有逆 数据较大的时候，海塞矩阵的计算量偏大 4. 参考 牛顿法、高斯—牛顿法（Gauss–Newton）和其他拟牛顿法","categories":[{"name":"最优化方法","slug":"最优化方法","permalink":"http://example.com/categories/%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"}],"tags":[]},{"title":"高斯牛顿法","slug":"最优化方法/高斯牛顿法","date":"2024-03-09T16:05:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/91eeeeac8bd1.html","permalink":"http://example.com/2024/03/91eeeeac8bd1.html","excerpt":"高斯牛顿法主要为了解决最小二乘问题，构造了能拟合替代海塞矩阵的矩阵，从而用牛顿法去求解最优值。","text":"高斯牛顿法主要为了解决最小二乘问题，构造了能拟合替代海塞矩阵的矩阵，从而用牛顿法去求解最优值。 1. 最小二乘问题 线性最小二乘 用直线 \\(y = \\theta^{T} x, x\\in R^{n}, y\\in R\\) 去拟合给定的输入输出数据，有 m 组数据，则构建残差模型： \\[ f(\\theta) = \\frac{1}{2} ||A\\theta-b||^{2} \\] 其中 \\[ \\begin{aligned} A = [x_{1},x_{2},x_{3}...x_{m}]^{T} \\quad x_{i} \\in R^{n}\\\\ b = [y_{1},y_{2},y_{3}...y_{m}]^{T} \\quad y_{i} \\in R \\end{aligned} \\] 线性最小二乘求解，直接对 \\(f(\\theta)\\) 求导，令导数为0，则可以得到： \\[ \\begin{aligned} \\frac{\\partial f(\\theta)}{\\partial \\theta} &amp;= A^{T}(A\\theta-b) \\\\ &amp; = 0 \\\\ \\end{aligned} \\] 所以直接求解得到： \\[ \\theta = (A^{T}A)^{-1}A^{T}b \\] 非线性最小二乘问题 对于目标函数： \\[ F(x) = \\frac{1}{2} ||f(x)||^{2} = \\frac{1}{2}f^{T}(x)f(x), \\quad f(x) = [f_{1}(x),f_{2}(x) ... f_{m}(x)]^{T}, \\quad x\\in R^{n} \\] 将 \\(f(x)\\) 在 \\(x_{k}\\) 处进行一阶泰勒展开，得到： \\[ f(x_{k+1}) = f(x_{k}) + J(x_{k}) (x_{k+1}-x_{k}) \\] 注意，这里的 \\(J(x_{k})\\) 是 \\(f(x)\\) 的一阶导数，而不是 \\(F(x)\\) 的一阶导数。则： \\[ \\begin{aligned} \\frac{\\partial F(x_{k+1})}{\\partial x_{k+1}} &amp;= \\frac{1}{2}f^{T}(x_{k+1})J(x_{k}) + \\frac{1}{2} J^{T}(x_{k})f(x_{k+1}) \\\\ &amp;=J^{T}(x_{k})f(x_{k}) + J^{T}(x_{k})J(x_{k})(x_{k+1} - x_{k}) \\end{aligned} \\] 按照高斯牛顿法的思想，需要一阶导数为零，则可以得到迭代时的递增方式： \\[ x_{k+1} = x_{k} - (J^{T}(x_{k})J(x_{k}))^{-1}J^{T}(x_{k})f(x_{k}) \\] 而原始目标函数 \\(F(x)\\) 的一阶导数： \\[ \\begin{aligned} g(x) &amp;= F&#39;(x) \\\\ &amp;= \\frac{1}{2}f^{T}(x)J(x) + \\frac{1}{2}J^{T}(x)f(x) \\\\ &amp;= J^{T}f(x) \\end{aligned} \\] 所以高斯牛顿法的步数递增可以表示为： \\[ x_{k+1} = x_{k} - (J^{T}(x_{k})J(x_{k}))^{-1}g(x_{k}) \\] 注意和牛顿法进行对比： !牛顿法 可以看出，高斯牛顿法就是使用 \\(J^{T}(x_{k})J(x_{k})\\) 来对原始目标函数 \\(F(x_{k})\\) 的海塞矩阵 \\(F&#39;&#39;(x_{k})\\) 进行了近似。 2. 高斯牛顿法局限性 \\(J^{T}(x_{k})J(x_{k})\\) 只具备半正定性质，但可能求解出来是奇异矩阵，导致求逆失败，从而计算下一步位置 \\(x_{k+1}\\) 失败； 当计算得到的 \\(x_{k+1}\\) 相对 \\(x_{k}\\) 的变化太大，从而用二阶展开无法近似函数，导致收敛失败。 3. 参考 参考1","categories":[{"name":"最优化方法","slug":"最优化方法","permalink":"http://example.com/categories/%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"}],"tags":[]},{"title":"Gazebo中bug集合","slug":"ROS/ROS笔记/Gazebo中bug集合","date":"2024-03-09T06:10:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/d3ca81927196.html","permalink":"http://example.com/2024/03/d3ca81927196.html","excerpt":"使用Gazebo的一系列报错集合。","text":"使用Gazebo的一系列报错集合。 1. 终端无法打开gazebo 终端输入 gazebo 后直接返回，并没有打开 gazebo，一般是后台有 gazebo 进程在跑。 首先查看是否有另一个 gazebo 进程打开 1gazebo --verbose 若报错并提示有进程已打开，则关闭 gazebo 进程即可 1killall gzserver 2. 更改机器人位置 两种方法更改位置","categories":[{"name":"ROS","slug":"ROS","permalink":"http://example.com/categories/ROS/"},{"name":"ROS笔记","slug":"ROS/ROS笔记","permalink":"http://example.com/categories/ROS/ROS%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Launch文件编写","slug":"ROS/ROS笔记/Launch文件编写","date":"2024-03-09T06:10:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/fc172c3ee8ff.html","permalink":"http://example.com/2024/03/fc172c3ee8ff.html","excerpt":"ROS1中launch文件的各项设置说明，包括变量、参数文件和话题重映射等；","text":"ROS1中launch文件的各项设置说明，包括变量、参数文件和话题重映射等； 1. 示例分析 这是一个在Rviz中加载 urdf 模型的launch文件，以此为例子进行launch文件分析。 12345678&lt;launch&gt; &lt;arg name=&quot;gui&quot; default=&quot;False&quot; /&gt; &lt;param name=&quot;robot_description&quot; command=&quot;cat $(find vehicle_description)/urdf/lexus.urdf&quot;/&gt; &lt;param name=&quot;use_gui&quot; value=&quot;$(arg gui)&quot;/&gt; &lt;node name=&quot;joint_state_publisher&quot; pkg=&quot;joint_state_publisher&quot; type=&quot;joint_state_publisher&quot;/&gt; &lt;node name=&quot;robot_state_publisher&quot; pkg=&quot;robot_state_publisher&quot; type=&quot;state_publisher&quot;/&gt; &lt;node name=&quot;rviz&quot; pkg=&quot;rviz&quot; type=&quot;rviz&quot; args=&quot;-d $(find urdf_tutorial)/urdf.rviz&quot; required=&quot;true&quot;/&gt;&lt;/launch&gt; 1.1 arg name &lt;arg name=\"**\" default =“False\"/&gt; 或者 &lt;arg name=“---\" value=”---\"/&gt; 这是launch文件的局部变量，供内部使用，可以看到在下面调用变量时使用$(arg **) 进行。 default=“---\" 是变量的默认值，可以在命令行中使用 roslaunch 命令时指定具体的值，例如: 1roslaunch vehicle_description dispaly.launch gui:=&quot;----&quot; //gui 是定义的变量名字 value=“---\" 就是指定了数值，无法更改。 1.2 param name &lt;param name=“---\" value=”---\" or command=\"命令\" or textfile=“文件path\"/&gt; 这是launch文件向ROS服务器ros master 传递的参数，可以直接指定数值，或者要传递的是一个文件，可以用textfile=“path\" 指定文件，或在这里使用command=”cat /filepath\" 的方式打开这个文件进行传递，cat 命令就是打开文件，这里与textfile=“---\" 效果相同。 1.3 rosparam file &lt;rosparam file =\"$(find 2dnav_pr2)/config/costmap_common_params.yaml\" command=\"load\" ns=\"local_costmap\" /&gt; 这是用yaml 配置文件的方式一次性载入多个参数，使用方法如上。 1.4 node name &lt;node name=\"---\" pkg=“---\" type=”----\"/&gt; 这里就是launch文件最为关键的启动节点的方法了。 pkg：节点所在的功能包名称 name：节点运行的名称，将覆盖节点中init()赋予节点的名称 type：节点的可执行文件名称 output = “screen”：将节点的标准输出打印到终端屏幕，默认输出为日志文档； respawn = \"true\"：复位属性，该节点停止时，会自动重启，默认为false； required = \"true\"：必要节点，当该节点终止时，launch文件中的其他节点也被终止； ns = \"namespace\"：命名空间，为节点内的相对名称添加命名空间前缀； args = \"arguments\"：节点需要的输入参数。 1.5 remap &lt;remap from=\"/turtlebot/cmd_vel\" to=\"/cmd_vel\"/&gt; 重映射，将/turtlebot/cmd_vel消息重映射为/cmd_vel消息 1.6 include &lt;include file=\"$(dirname)/other.launch\" /&gt; 用include包含其他launch文件。","categories":[{"name":"ROS","slug":"ROS","permalink":"http://example.com/categories/ROS/"},{"name":"ROS笔记","slug":"ROS/ROS笔记","permalink":"http://example.com/categories/ROS/ROS%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"ROS控制程序时间间隔","slug":"ROS/ROS笔记/ROS控制程序时间间隔","date":"2024-03-09T06:10:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/8fcfbb5a0ae4.html","permalink":"http://example.com/2024/03/8fcfbb5a0ae4.html","excerpt":"","text":"ros::Duration(1.0).sleep() 在当前位置阻塞 1s","categories":[{"name":"ROS","slug":"ROS","permalink":"http://example.com/categories/ROS/"},{"name":"ROS笔记","slug":"ROS/ROS笔记","permalink":"http://example.com/categories/ROS/ROS%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"rqt_plot使用","slug":"ROS/ROS笔记/rqt_plot使用","date":"2024-03-09T06:10:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/21ac3347f9de.html","permalink":"http://example.com/2024/03/21ac3347f9de.html","excerpt":"ROS中进行数据实时可视化的工具 rqt_plot 的使用介绍；","text":"ROS中进行数据实时可视化的工具 rqt_plot 的使用介绍； 1. 启用命令 1rqt_plot /current_velocity/twist/linear/x 2. 调节轴距 界面上的 “放大镜” 工具，鼠标右键可以缩小界面。","categories":[{"name":"ROS","slug":"ROS","permalink":"http://example.com/categories/ROS/"},{"name":"ROS笔记","slug":"ROS/ROS笔记","permalink":"http://example.com/categories/ROS/ROS%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"话题与消息","slug":"ROS/ROS笔记/话题与消息","date":"2024-03-09T06:10:00.000Z","updated":"2024-03-11T00:51:43.638Z","comments":true,"path":"2024/03/f028da3460ac.html","permalink":"http://example.com/2024/03/f028da3460ac.html","excerpt":"ROS中话题与消息的定义和使用； 消息发布的cpp程序示例； 消息订阅的cpp程序示例；","text":"ROS中话题与消息的定义和使用； 消息发布的cpp程序示例； 消息订阅的cpp程序示例； 1. ROS 中话题与消息 1.1 定义 ROS 中各节点之间的通信使用消息传递，消息有组织的存放在话题里，节点发布消息到话题里或者订阅话题以获得其他的消息。 1.2 查看当前的节点图 1rqt_graph 使用该命令可以得到当前的节点图，节点与节点之间展示的是其通信的话题。 1.3 查看消息的一些命令 12345678910rostopic list // 获得当前的活跃话题rostopic echo topic-name //在终端中显示该话题上发布的消息rostopic hz topic-name // 测试消息发布的频率rostopic bw topic-name // 测试每秒中发布消息所占的字节量rostopic info topic-name // 查看话题的基本信息，包括消息类型(Type),发布节点(Publishers),订阅节点(Subscribers)rosmsg show message-type-name //查看消息的详情rostopic pub -r rate-in-hz topic-name msg-type msg-content //使用命令行发布消息，其中 rate-in-hz 为发布频率rostopic pub -r 1 /turtle1/cmd_vel geometry_msgs/Twist &#x27;[0,0,0]&#x27;&#x27;[0,0,1]&#x27; //例子 1.4 消息的命名 1package-name/type-name //第一项为消息所属包名，第二项为消息类型名 1.5 一些注意事项 话题通信是多对多的，即同一个话题可以有多个发布者和多个订阅者。 ROS节点是松耦合的，一个节点不依赖于另外一个节点，节点之间唯一的交互就是基于话题和消息的同通信，即使只有一个节点也可以单独运行，因为它会一直等待订阅的话题，而不会直接报错。 消息的内容除了在命令行中显式的书写，还可以写在 YAML 文件中，从而直接载入文件。 1.6 使用 rostopic pub 直接发布命令 使用 rostopic pub 可以直接在命令行发布消息，格式就如同上面所示，但是由于消息的格式通常很复杂，所以 bash 命令行中给出了足够的优化，主要输入完话题名后，按 Tab 键可以补全消息类型，再按 Tab 还可以直接给出消息的格式，直接填写即可。 1234567891011rostopic pub -1 /initialpose geometry_msgs/PoseWithCovarianceStamped &quot;header: seq: 0 stamp: secs: 0 nsecs: 0 frame_id: &#x27;world&#x27;pose: pose: position: &#123;x: 24.5, y: -7.15, z: 0.276&#125; orientation: &#123;x: 0.0, y: 0.0, z: 0.0, w: 0.0&#125; covariance: [0.25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.06853892326654787]&quot; 2. ROS 中消息发布 2.1 消息发布节点程序示例 123456789101112131415161718192021222324252627282930# &lt;ros/ros.h&gt;#include &lt;geometry_msgs/Twist.h&gt; //引入需要发布的消息类型，&quot;geometry_msgs&quot;是定义消息的功能包，”Twist“ 是消息类型#include &lt;stdlib.h&gt;int main(int argc, char **argv)&#123; ros::init(argc,argv,&quot;publish_velocity&quot;); //初始化ROS, 每个程序都需要，至于其内部结构再观察，&quot;publish_velocity&quot; 是该节点的名字 ros::NodeHandle nh; //创建节点处理对象 ros::Publisher pub = nh.advertise&lt;geometry_msgs::Twist&gt;(&quot;turtle1/cmd_vel&quot;,1000) //生成一个发布对象，详细见说明1 srand(time(0)); Ros::Rate rate(2); //控制循环速度，单位是HZ，也就控制了消息发布的速度，这里将循环控制到每秒2次 while(ros::ok()) // 使用 ros::ok()判断节点是否正常工作 &#123; geometry_msgs::Twist msg; //创建消息对象 msg.linear.x = double(rand())/double(RAND_MAX); //可以看出消息的每个域都被按照其层级关系变成了类的共有成员，以便进行赋值 msg.angular.z = 2*double(rand())/double(RAND_MAX)-1; pub.publish(msg); // ROS_INFO_STREAM 是ros中一个类似输出流的设置，可在终端中看到输出 ROS_INFO_STREAM(&quot;sending random velocity command:&quot;&lt;&lt;&quot;linear=&quot;&lt;&lt;msg.linear.x&lt;&lt;&quot;angular=&quot;&lt;&lt;msg.angular.z); rate.sleep(); //配合rate(2)的设定，控制循环速度 &#125; &#125; 2.2 说明 2.2.1 创建发布对象 1ros::Publisher pub=node_handle.advertise&lt;message_type&gt;(topic_name,queue_size) message_type 是消息类型，是C++的对象定义 topic_name 是字符串，是话题名，注意没有前斜杠(/)，例如本例子中 \"turtle1/cmd_vel\", 在 rostopic list 列出的是/turtle1/cmd_vel，这里甚至可以是自己定义的话题名，不需要严格被限制到官方的话题中。 queue_size 是发布队列的大小，publish方法其实是将消息放到队列里，然后后台有线程负责实际发送消息，然后这个队列大小在这里定义，数字代表能容纳的消息数量。 2.2.2 节点是否停止工作的检查： 1ros::ok() 如果一直运行良好，则返回true，否则返回false 使用 Ctrl-C 会返回false，但不是立刻终止该结点，而是会接着进行剩下的程序，这对于必要的收尾工作很重要。 2.2.3 编译相关： 修改CMakeLists.txt 文件，声明消息的依赖库： 1find_package(catkin REQUIRED COMPONENTS roscpp geometry_msgs) 修改 package.xml 文件，添加依赖项 12&lt;build_depend&gt;geometry_msgs&lt;/build_depend&gt;&lt;run_depend&gt;geometry_msgs&lt;/run_depend&gt; 3. ROS 中消息订阅 3.1 消息订阅程序示例 123456789101112131415161718#include &lt;ros/ros.h&gt;#include &lt;turtlesim/Pose.h&gt; //同样需要引入消息#include &lt;iomanip&gt; // 需要设置输出的浮点数精度void poseMessageReceived(const turtlesim::Pose &amp;msg) //回调函数，当接收到消息时自动执行的程序，输入参数为需要接受的消息类型的引用&#123; ROS_INFO_STREAM(std::setprecision(2)&lt;&lt;std::fixd&lt;&lt;&quot;position=(&quot;&lt;&lt;msg.x&lt;&lt;&quot;,&quot;&lt;&lt;msg.y&lt;&lt;&quot;)&quot;&lt;&lt;&quot;*direction=&quot;&lt;&lt;msg.theta);&#125;int main(int argc, char **argv)&#123; ros::init(argc,argv,&quot;subscribe_to_pose&quot;); //常规操作，初始化 ros::NodeHandle nh; ros::Subscriber sub = nh.subscribe(&quot;turtle1/pose&quot;,1000,&amp;poseMessageReceived); //创建一个订阅对象，详见说明1 ros::spin();//等待并执行回调函数，类似 while() 循环&#125; 3.2 说明 3.2.1 创建订阅对象 1ros::Subscriber sub = node_handle.subscribe(topic_name,queue_size,pointer_to_callback_function) 注意这里不同于发布者需要以模板参数形式指定消息类型，所以一个订阅对象是不需要知道消息类型的，主要通过回调函数去确认消息类型。 topic_name 同发布对象。 queue_size 是订阅队列的大小。ros 中新消息到达时会被保存到一个队列中，这里定义这个队列的大小，需要等待回调函数去取出消息，这里清空队列的速度取决于回调函数的执行速度，所以回调函数的计算时间一般不过长，以免丢失消息。 pointer_to_callback_function 是指向回调函数的指针，注意只能用名字，不能加函数的括号()。 3.2.2 ros::spin()与 ros::spinOnce() 区别 其处理机制详见这篇文章。每次有新的消息到达，都会有回调函数进入回调函数队列然后直到主程序中有这俩函数时，才会去回调函数队列中取队头函数，并执行。 主要使用区别在于当程序中还有没有其他重复工作需要做，如果不需要，则使用ros::spin() 就可以； 如果需要，那就写一个循环，循环内先做其他的重复工作，然后使用ros::spinOnce() 来处理回调。 ros::spin() 相当于 1234while(ros::ok())&#123; ros::spinOnce();&#125;","categories":[{"name":"ROS","slug":"ROS","permalink":"http://example.com/categories/ROS/"},{"name":"ROS笔记","slug":"ROS/ROS笔记","permalink":"http://example.com/categories/ROS/ROS%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"工作空间建立与编译","slug":"ROS/ROS笔记/工作空间建立与编译","date":"2024-03-09T06:09:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/cfa9782ab392.html","permalink":"http://example.com/2024/03/cfa9782ab392.html","excerpt":"ROS工作空间初始化、创建和查询功能包； 更换网络导致的报错问题；","text":"ROS工作空间初始化、创建和查询功能包； 更换网络导致的报错问题； 1. 工作空间建立与编译 1.1 新建 ROS 工作空间 1234567mkdir -p ~/lkx_ws/srccd ~/lkx_ws/srccatkin_init_workspace cd ../catkin_makesouce devel/setup.bash 1.2 在ROS工作空间中新建功能包及相关编译选项 12catkin_create_pkg my_pkg roscpp rospy std_msgs // 第一个参数是包名，后面是依赖项。catkin_make // 在src同级文件夹进行编译，注意看终端输出，有可能还需要在build文件夹下进行make编译 1.3 在工作空间中查询功能包是否存在 1rospack find pkg_name 2. 因为更换网络导致IP地址变化的报错 在 .bashrc 中更换ROS的通讯IP为当前电脑的IP 1sudo gedit ./bashrc","categories":[{"name":"ROS","slug":"ROS","permalink":"http://example.com/categories/ROS/"},{"name":"ROS笔记","slug":"ROS/ROS笔记","permalink":"http://example.com/categories/ROS/ROS%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"ROS笔记索引","slug":"ROS/ROS笔记索引","date":"2024-03-08T16:05:36.000Z","updated":"2024-03-12T02:49:19.372Z","comments":true,"path":"2024/03/81afc0fb8e6d.html","permalink":"http://example.com/2024/03/81afc0fb8e6d.html","excerpt":"本页面主要存放ROS开发中记录的笔记索引，方便查找对应文章。","text":"本页面主要存放ROS开发中记录的笔记索引，方便查找对应文章。 1. 教程 工作空间建立与编译 话题与消息 Launch文件编写 ROS控制程序时间间隔 rqt_plot使用 2. 避坑 Gazebo中bug集合","categories":[{"name":"ROS","slug":"ROS","permalink":"http://example.com/categories/ROS/"}],"tags":[{"name":"#ROS笔记检索","slug":"ROS笔记检索","permalink":"http://example.com/tags/ROS%E7%AC%94%E8%AE%B0%E6%A3%80%E7%B4%A2/"}]},{"title":"共轭梯度法","slug":"最优化方法/共轭梯度法","date":"2024-03-04T16:00:00.000Z","updated":"2024-03-11T00:51:43.637Z","comments":true,"path":"2024/03/528ef78b9929.html","permalink":"http://example.com/2024/03/528ef78b9929.html","excerpt":"解决求无约束优化问题的极值点的问题。 对于n维度的二次型目标函数，可在n次搜索后得到极值点。 每次搜索方向为共轭方向。","text":"解决求无约束优化问题的极值点的问题。 对于n维度的二次型目标函数，可在n次搜索后得到极值点。 每次搜索方向为共轭方向。 1. 为什么要用共轭梯度 梯度下降法受限制于搜索步长的学习率问题，可能需要多次搜索才能达到极值点； 最速下降法每次的下降方向都和上次的正交，因此会产生锯齿现象，在靠近极值点的时候会多次缓慢搜索。那么在同一个方向上可能多次下降，这不如一次在这个方向上一次搜索到底。 2. 共轭向量法 对于无约束的二次型目标函数： \\[ f(x) = \\frac{1}{2} x^{T}Ax -b^{T}x \\] 其中 \\(A\\) 是对称正定的，问题在于求取其最小值点 \\(x^{*}\\)。也可以说是求以下方程的解，这两个问题等效。 \\[ Ax = b \\] 定理：若矩阵A为对称正定阵，并且一组向量 \\(\\{d_{0},d_{1}, ...,d_{m}\\}\\) 是关于A共轭的，那么这组向量是线性无关的。 说明：向量组\\(\\{d_{0},d_{1}, ...,d_{m}\\}\\)关于矩阵A共轭，即 \\[ d_{i}^{T}Ad_{j} = 0, \\qquad \\{i \\neq j\\} \\] 可以选取一组共轭向量作为每次变量迭代的方向，即 \\(\\{d_{0},d_{1},d_{2}, ... , d_{n-1} \\}\\)，假设目标函数极值点为 \\(x^{*}\\)，则 \\[ x^{*} = x_{0} + \\alpha_{0}d_{0} + \\alpha_{1} d_{1}+ ...+ \\alpha_{n-1}d_{n-1} \\] 从 \\(x_{i}\\) 迭代到 \\(x_{i+1}\\) 的表达式为： \\[ x_{i+1} = x_{i} + \\alpha_{i} d_{i} \\] 那么 \\(d_{i}\\) 作为已知的方向，现在只需要求在这个方向上的步长 \\(\\alpha_{i}\\) 。 对于第 \\(i\\) 步时，我们有 \\[ \\begin{aligned} d_{i}^{T} A &amp;(x^{*} - x_{0}) = \\alpha_{i} d_{i}^{T} Ad_{i} ^{T} \\\\ ~\\\\ \\alpha_{i} &amp;= \\frac{d_{i}^{T} A (x^{*} - x_{0})}{ d_{i}^{T} Ad_{i} ^{T}} \\\\ &amp;=\\frac{d_{i}^{T} A (x^{*} - x_{i})}{ d_{i}^{T} Ad_{i} ^{T}} + \\frac{d_{i}^{T} A (x_{i} - x_{0})}{ d_{i}^{T} Ad_{i} ^{T}} \\\\ &amp;= -\\frac{d_{i}^{T} (Ax_{i}-b)}{ d_{i}^{T} Ad_{i} ^{T}} + 0 \\\\ &amp;= -\\frac{d_{i}^{T}g_{i}}{ d_{i}^{T} Ad_{i} ^{T}} \\end{aligned} \\] 所以，迭代公式就为： \\[ x_{i+1} = x_{i} - \\frac{d_{i}^{T}g_{i}}{ d_{i}^{T} Ad_{i} ^{T}} d_{i} \\] 这叫做共轭向量法。前提是知道二次项系数 \\(A\\) 的一组完备的共轭向量组。这里加入了一些限制，比如 \\(A\\) 是对称矩阵，则其共轭向量组是正交的，也是共轭的。那么共轭向量组就是其特征向量组。 共轭方向定理：记向量 \\(\\{ d_{0},d_{1},…,d_{n−1}\\}\\) 是 A 共轭的， \\(x_{0} \\in R^{n}\\) 是任意的一个 n 维向量，则按照 \\(x_{i+1} = x_{i} + \\alpha_{i} d_{i},g_{i} =Ax_{i}-b,\\alpha_{i} = \\frac{d_{i}^{T}g_{i}}{ d_{i}^{T} Ad_{i} ^{T}}\\) 的迭代格式进行 n 步迭代，我们就能得到 \\(x_{n} = x^{*}\\)。 3. 共轭梯度法 在共轭向量法中，每次搜索的方向就是一个共轭向量的方向，共轭向量组需要事先获得。但要是可以在迭代过程中逐步获得当前的搜索方向，也就是共轭梯度，那就更好了。 在第一次迭代给定初值 \\(x_{0}\\) 后，此时的搜索方向设定为梯度方向，即 \\[ d_{0} = -g_{0} \\] 对于 \\(x_{i+1}\\) 时的搜索方向，我们可认为是上一位置的搜索方向 \\(d_{i}\\) 和当前位置的梯度方向 \\(g_{i+1}\\) 的线性组合： \\[ d_{i+1} = -g_{i+1} + \\beta_{i} d_{i} \\] 那么，要求解得到这个 \\(\\beta_{i}\\)： \\[ \\begin{aligned} d_{i}^{T} A d_{i+1} = 0 \\\\ ~\\\\ d_{i}^{T}A(-g_{i+1}+\\beta_{i}d_{i}) = 0 \\\\ ~\\\\ \\beta_{i} = \\frac{d_{i}^{T}Ag_{i+1}}{d_{i}^{T}Ad_{i}} \\end{aligned} \\] 于是对于共轭梯度法，迭代步骤便如下： 1. 令 \\(k := 0\\)； 选择初始值 \\(x_{0}\\)。 2. 计算 \\(g_{0} = \\nabla f(x_{0})\\) ，若 \\(g_{0} = 0\\) ，停止迭代，否则令 \\(d_{0} = g_{0}\\)； 4. 计算 \\(\\alpha_{0} =-\\frac{d_{0}^{T}g_{0}}{d_{0}^{T} Ad_{0} ^{T}}\\)； 5. 完成第一次迭代： \\(x_{1} = x_{0} + \\alpha_{0} d_{0}\\)； 6. 计算 \\({i+1}\\) 时刻梯度 \\(g_{i+1} = \\nabla f(x_{i+1})\\) ； 7. 计算 \\(i+1\\) 时刻搜索方向 \\(d_{i+1} = -g_{i+1} + \\beta_{i} d_{i}\\)， 其中\\(\\beta_{i} = \\frac{d_{i}^{T}Ag_{i+1}}{d_{i}^{T}Ad_{i}}\\)。 8. 计算 \\(i+1\\) 时刻步长 \\(\\alpha_{i+1} = -\\frac{d_{i+1}^{T}g_{i+1}}{ d_{i+1}^{T} Ad_{i+1} ^{T}}\\)； 9. 搜索得到 \\(i+2\\) 时刻 \\(x_{i+2} = x_{i+1}+\\alpha_{i+1}d_{i+1}\\) 4. 补充 共轭法的每一个方向的步长是确定的，不然没有办法最终 \\(n\\) 步到达极值点（极值点是共轭向量的线性组合）。当然也可以设置为固定步长的学习率，这就不能保证 \\(n\\) 步之后到达极值点了。 共轭向量组的求解有很多方法，这里是假定当前搜索方向是当前梯度和上一位置搜索方向的线性组合。还有一些其他方法： Fletcher-Reeves （FR）法： \\(\\beta_{i} = \\frac{g_{i+1}^{T}g_{i+1}}{g_{i}^{T}g_{i}}\\) Polak-Ribière （PR）法：\\(\\beta_{i} =\\frac{g_{i+1}^{T}(g_{i+1} - g_{i})}{g_{i}^{T}g_{i}}\\)","categories":[{"name":"最优化方法","slug":"最优化方法","permalink":"http://example.com/categories/%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"}],"tags":[]}],"categories":[{"name":"环境配置日志","slug":"环境配置日志","permalink":"http://example.com/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97/"},{"name":"最优化方法","slug":"最优化方法","permalink":"http://example.com/categories/%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"},{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"实用代码","slug":"Python/实用代码","permalink":"http://example.com/categories/Python/%E5%AE%9E%E7%94%A8%E4%BB%A3%E7%A0%81/"},{"name":"Python语言特性","slug":"Python/Python语言特性","permalink":"http://example.com/categories/Python/Python%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/categories/Ubuntu/"},{"name":"linux笔记","slug":"Ubuntu/linux笔记","permalink":"http://example.com/categories/Ubuntu/linux%E7%AC%94%E8%AE%B0/"},{"name":"ROS","slug":"ROS","permalink":"http://example.com/categories/ROS/"},{"name":"ROS笔记","slug":"ROS/ROS笔记","permalink":"http://example.com/categories/ROS/ROS%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"#环境配置索引","slug":"环境配置索引","permalink":"http://example.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%B4%A2%E5%BC%95/"},{"name":"#最优化方法索引","slug":"最优化方法索引","permalink":"http://example.com/tags/%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E7%B4%A2%E5%BC%95/"},{"name":"#Python笔记索引","slug":"Python笔记索引","permalink":"http://example.com/tags/Python%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95/"},{"name":"#linux笔记检索","slug":"linux笔记检索","permalink":"http://example.com/tags/linux%E7%AC%94%E8%AE%B0%E6%A3%80%E7%B4%A2/"},{"name":"#ROS笔记检索","slug":"ROS笔记检索","permalink":"http://example.com/tags/ROS%E7%AC%94%E8%AE%B0%E6%A3%80%E7%B4%A2/"}]}